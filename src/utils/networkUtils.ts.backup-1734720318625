import { retry, RetryOptions } from './retry';

/**
 * Utility class for handling network-related operations
 */
export class NetworkUtils {
  /** Default number of retry attempts */
  private static readonly DEFAULT_RETRY_COUNT = 3;
  /** Default delay between retries in milliseconds */
  private static readonly DEFAULT_RETRY_DELAY = 1000; // 1 second
  /** Maximum delay between retries in milliseconds */
  private static readonly MAX_RETRY_DELAY = 30000; // 30 seconds

  /**
   * Waits for network connection to be restored
   * @returns Promise that resolves when connection is available
   */
  public static async waitForConnection(): Promise<boolean> {
    // Handle environments without window/navigator (e.g., SSR)
    if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {
      return true;
    }

    return new Promise((resolve) => {
      if (window.navigator.onLine) {
        resolve(true);
        return;
      }

      const handleOnline = () => {
        window.removeEventListener('online', handleOnline);
        resolve(true);
      };

      window.addEventListener('online', handleOnline);
    });
  }

  /**
   * Checks if the network is currently available
   * @returns Whether network connection is available
   */
  public static isOnline(): boolean {
    return typeof window !== 'undefined' && window.navigator.onLine;
  }

  /**
   * Makes a network request with automatic retries
   * @param fn Function that makes the network request
   * @param options Retry options
   * @returns Promise that resolves with the request result
   */
  public static async withRetry<T>(
    fn: () => Promise<T>,
    options?: Partial<RetryOptions>
  ): Promise<T> {
    const retryOptions: RetryOptions = {
      maxAttempts: options?.maxAttempts ?? this.DEFAULT_RETRY_COUNT,
      initialDelay: options?.initialDelay ?? this.DEFAULT_RETRY_DELAY,
      maxDelay: options?.maxDelay ?? this.MAX_RETRY_DELAY,
      shouldRetry: options?.shouldRetry ?? ((error: unknown) => {
        // Default retry conditions
        if (error instanceof Error) {
          const message = error.message.toLowerCase();
          return (
            message.includes('network') ||
            message.includes('timeout') ||
            message.includes('econnrefused') ||
            message.includes('econnreset')
          );
        }
        return false;
      })
    };

    return retry(fn, retryOptions);
  }

  /**
   * Makes a network request with automatic connection check
   * @param fn Function that makes the network request
   * @param options Retry options
   * @returns Promise that resolves with the request result
   */
  public static async withConnection<T>(
    fn: () => Promise<T>,
    options?: Partial<RetryOptions>
  ): Promise<T> {
    if (!this.isOnline()) {
      await this.waitForConnection();
    }

    return this.withRetry(fn, options);
  }

  /**
   * Makes a network request with timeout
   * @param fn Function that makes the network request
   * @param timeoutMs Timeout in milliseconds
   * @returns Promise that resolves with the request result
   * @throws Error if request times out
   */
  public static async withTimeout<T>(
    fn: () => Promise<T>,
    timeoutMs: number
  ): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Request timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });

    return Promise.race([fn(), timeoutPromise]);
  }

  /**
   * Makes a network request with all safety measures
   * @param fn Function that makes the network request
   * @param timeoutMs Timeout in milliseconds
   * @param retryOptions Retry options
   * @returns Promise that resolves with the request result
   */
  public static async withSafety<T>(
    fn: () => Promise<T>,
    timeoutMs: number,
    retryOptions?: Partial<RetryOptions>
  ): Promise<T> {
    const safeFn = () => this.withTimeout(fn, timeoutMs);
    return this.withConnection(safeFn, retryOptions);
  }
}
