import { isRetryableError } from './errors';

export interface RetryOptions;

export interface RetryResult;


/**
 * Options for configuring retry behavior
 */

  /** Base delay between retries in milliseconds */
  delayMs?: number;
  /** Maximum delay between retries in milliseconds */
  maxDelayMs?: number;
  /** Function to determine if an error should trigger a retry */
  shouldRetry?: (error: unknown) => boolean;
  /** Callback function called before each retry attempt */
  onRetry?: (attempt: number, error: unknown) => void | Promise<void>;
  /** Whether to use exponential backoff for retry delays */
  useExponentialBackoff?: boolean;
}

/**
 * Result of a retried operation
 */

  /** The last error encountered if the operation failed */
  error: unknown | null;
  /** Whether the operation was successful */
  success: boolean;
  /** Number of retry attempts made */
  attempts: number;
}

/**
 * Default retry options
 */
const DEFAULT_OPTIONS: Required<RetryOptions> = {
  maxAttempts: 3,
  delayMs: 1000,
  maxDelayMs: 30000,
  shouldRetry: isRetryableError,
  onRetry: () => {},
  useExponentialBackoff: true
};

/**
 * Sleep for a specified duration
 * @param ms Duration in milliseconds
 */
async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => {
    window.setTimeout(resolve, ms);
  });
}

/**
 * Calculate delay for the next retry attempt
 * @param attempt Current attempt number
 * @param options Retry options
 * @returns Delay in milliseconds
 */
function calculateDelay(attempt: number, options: Required<RetryOptions>): number {
  const { delayMs, maxDelayMs, useExponentialBackoff } = options;
  
  if (!useExponentialBackoff) {
    return Math.min(delayMs, maxDelayMs);
  }

  const exponentialDelay = delayMs * Math.pow(2, attempt - 1);
  const delay = Math.min(exponentialDelay, maxDelayMs);
  
  // Add jitter to prevent thundering herd
  return delay + (Math.random() * delayMs * 0.1);
}

/**
 * Execute an async function with automatic retries
 * @param fn Function to execute
 * @param options Retry configuration
 * @returns Promise resolving to the function result
 */
export async function retry<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<RetryResult<T>> {
  const opts = { ...DEFAULT_OPTIONS, ...options } as Required<RetryOptions>;
  let attempt = 1;
  let lastError: unknown = null;

  while (attempt <= opts.maxAttempts) {
    try {
      const data = await fn();
      return {
        data,
        error: null,
        success: true,
        attempts: attempt
      };
    } catch (error) {
      lastError = error;

      if (attempt === opts.maxAttempts || !opts.shouldRetry(error)) {
        break;
      }

      await opts.onRetry(attempt, error);
      await sleep(calculateDelay(attempt, opts));
      attempt++;
    }
  }

  return {
    data: null,
    error: lastError,
    success: false,
    attempts: attempt
  };
}

/**
 * Create a retryable version of an async function
 * @param fn Function to make retryable
 * @param options Default retry options
 * @returns Wrapped function with retry behavior
 */
export function withRetry<T, Args extends unknown[]>(
  fn: (...args: Args) => Promise<T>,
  options: RetryOptions = {}
): (...args: Args) => Promise<RetryResult<T>> {
  return (...args: Args) => retry(() => fn(...args), options);
}

/**
 * Create a retry strategy with custom configuration
 * @param options Default retry options
 * @returns Function to execute with this retry strategy
 */
export function createRetryStrategy(
  options: RetryOptions = {}
): <T>(fn: () => Promise<T>) => Promise<RetryResult<T>> {
  return <T>(fn: () => Promise<T>) => retry(fn, options);
}

undefined.displayName = 'undefined';