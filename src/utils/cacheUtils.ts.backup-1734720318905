import { debugLog } from '../config/cacheConfig';

import type { Region } from '../services/locations/regions';
import type { TimeSlot } from '../types';

export interface CacheMetrics;
export interface MockDataScenario;
export type CacheMetrics;
export type MockDataScenario;

export interface CacheMetrics;
export interface MockDataScenario;
export type CacheMetrics;
export type MockDataScenario;

/**
 * Cache performance metrics
 */
export interface CacheMetrics {
  /** Number of cache hits */
  hits: number;
  /** Number of cache misses */
  misses: number;
  /** Number of cache evictions */
  evictions: number;
  /** Current cache size */
  size: number;
  /** Average time to access cache entries */
  averageAccessTime: number;
}

/**
 * Mock data scenario for testing
 */
export interface MockDataScenario {
  /** Name of the scenario */
  name: string;
  /** List of time slots */
  slots: TimeSlot[];
  /** Region for the scenario */
  region: Region;
}

/**
 * Monitors cache performance and provides utilities
 */
class CacheMonitor {
  private static instance: CacheMonitor;
  private metrics: CacheMetrics = {
    hits: 0,
    misses: 0,
    evictions: 0,
    size: 0,
    averageAccessTime: 0
  };
  private accessTimes: number[] = [];
  private readonly maxAccessTimes = 1000;

  private constructor() {
    // Private constructor to enforce singleton
  }

  /**
   * Gets the singleton instance of CacheMonitor
   */
  public static getInstance(): CacheMonitor {
    if (!CacheMonitor.instance) {
      CacheMonitor.instance = new CacheMonitor();
    }
    return CacheMonitor.instance;
  }

  /**
   * Records a cache hit
   * @param accessTime Time taken to access the cache
   */
  public recordHit(accessTime: number): void {
    this.metrics.hits++;
    this.updateAccessTime(accessTime);
    debugLog('Cache hit', { accessTime });
  }

  /**
   * Records a cache miss
   */
  public recordMiss(): void {
    this.metrics.misses++;
    debugLog('Cache miss');
  }

  /**
   * Records a cache eviction
   */
  public recordEviction(): void {
    this.metrics.evictions++;
    debugLog('Cache eviction');
  }

  /**
   * Updates the cache size
   * @param size New cache size
   */
  public updateSize(size: number): void {
    this.metrics.size = size;
    debugLog('Cache size updated', { size });
  }

  /**
   * Gets current cache metrics
   */
  public getMetrics(): CacheMetrics {
    return { ...this.metrics };
  }

  /**
   * Resets cache metrics
   */
  public resetMetrics(): void {
    this.metrics = {
      hits: 0,
      misses: 0,
      evictions: 0,
      size: 0,
      averageAccessTime: 0
    };
    this.accessTimes = [];
    debugLog('Cache metrics reset');
  }

  private updateAccessTime(time: number): void {
    this.accessTimes.push(time);
    if (this.accessTimes.length > this.maxAccessTimes) {
      this.accessTimes.shift();
    }
    this.metrics.averageAccessTime =
      this.accessTimes.reduce((sum, t) => sum + t, 0) / this.accessTimes.length;
  }
}

/**
 * Generates a mock time slot
 * @param date Date for the time slot
 * @param available Whether the slot is available
 * @returns Generated time slot
 */
export function generateTimeSlot(date: Date, available = true): TimeSlot {
  const startTime = new Date(date);
  startTime.setMinutes(Math.floor(startTime.getMinutes() / 30) * 30);
  startTime.setSeconds(0);
  startTime.setMilliseconds(0);

  return {
    id: `slot_${startTime.getTime()}`,
    startTime,
    endTime: new Date(startTime.getTime() + 30 * 60 * 1000),
    available,
    overlapping: []
  };
}

/**
 * Generates mock data for testing
 * @param scenario Scenario name
 * @returns Mock data scenario
 */
export function generateMockData(scenario = 'normal'): MockDataScenario {
  const now = new Date();
  const slots: TimeSlot[] = [];

  switch (scenario) {
    case 'busy':
      // Generate busy day with limited availability
      for (let hour = 9; hour < 18; hour++) {
        slots.push(
          generateTimeSlot(
            new Date(now.setHours(hour, 0)),
            Math.random() > 0.8
          ),
          generateTimeSlot(
            new Date(now.setHours(hour, 30)),
            Math.random() > 0.8
          )
        );
      }
      return {
        name: 'Busy Day',
        slots,
        region: 'NORTH'
      };

    case 'empty':
      // Generate day with no availability
      for (let hour = 9; hour < 18; hour++) {
        slots.push(
          generateTimeSlot(new Date(now.setHours(hour, 0)), false),
          generateTimeSlot(new Date(now.setHours(hour, 30)), false)
        );
      }
      return {
        name: 'No Availability',
        slots,
        region: 'SOUTH'
      };

    default:
      // Generate normal day with good availability
      for (let hour = 9; hour < 18; hour++) {
        slots.push(
          generateTimeSlot(new Date(now.setHours(hour, 0))),
          generateTimeSlot(new Date(now.setHours(hour, 30)))
        );
      }
      return {
        name: 'Normal Day',
        slots,
        region: 'CENTRAL'
      };
  }
}

/**
 * Checks if a cache entry has expired
 * @param timestamp Timestamp of the cache entry
 * @param maxAge Maximum age in milliseconds
 * @returns Whether the cache entry has expired
 */
export function isCacheExpired(timestamp: number, maxAge = 300000): boolean {
  return Date.now() - timestamp > maxAge;
}

/**
 * Generates a cache key for a region and date
 * @param region Region
 * @param date Date
 * @returns Cache key
 */
export function getCacheKey(region: Region, date: Date): string {
  const dateStr = date.toISOString().split('T')[0];
  return `${region}_${dateStr}`;
}

export { CacheMonitor, type CacheMetrics, type MockDataScenario };
