/**
 * Utility functions for object manipulation
 */

/**
 * Primitive types supported by the object utilities
 */
type Primitive = string | number | boolean | null | undefined;

/**
 * Makes all properties in T optional recursively
 */
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Deep equality comparison of two objects
 * @param obj1 First object to compare
 * @param obj2 Second object to compare
 * @returns Whether objects are deeply equal
 */
export function isEqual(obj1: unknown, obj2: unknown): boolean {
  if (obj1 === obj2) {
    return true;
  }

  if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || !obj1 || !obj2) {
    return false;
  }

  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (const key of keys1) {
    if (!isEqual((obj1 as Record<string, unknown>)[key], (obj2 as Record<string, unknown>)[key])) {
      return false;
    }
  }

  return true;
}

/**
 * Deep merge multiple objects
 * @template T Type of objects to merge
 * @param objects Objects to merge
 * @returns Merged object
 */
export function deepMerge<T extends object>(...objects: DeepPartial<T>[]): T {
  const result = {} as T;

  for (const obj of objects) {
    if (!obj) continue;

    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const value = obj[key];
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          result[key] = deepMerge(result[key] || {}, value);
        } else {
          result[key] = value as T[Extract<keyof T, string>];
        }
      }
    }
  }

  return result;
}

/**
 * Remove undefined properties from an object
 * @template T Type of object to clean
 * @param obj Object to clean
 * @returns Cleaned object (same reference)
 */
export function removeUndefined<T extends object>(obj: T): T {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      if (value === undefined) {
        delete obj[key];
      } else if (value && typeof value === 'object') {
        removeUndefined(value);
      }
    }
  }
  return obj;
}

/**
 * Create a new object with only the specified keys
 * @template T Type of source object
 * @template K Keys to pick from T
 * @param obj Source object
 * @param keys Keys to pick
 * @returns New object with only picked keys
 */
export function pick<T extends object, K extends keyof T>(
  obj: T,
  keys: K[]
): Pick<T, K> {
  const result = {} as Pick<T, K>;
  for (const key of keys) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

/**
 * Create a new object without the specified keys
 * @template T Type of source object
 * @template K Keys to omit from T
 * @param obj Source object
 * @param keys Keys to omit
 * @returns New object without omitted keys
 */
export function omit<T extends object, K extends keyof T>(
  obj: T,
  keys: K[]
): Omit<T, K> {
  const result = { ...obj } as Omit<T, K>;
  for (const key of keys) {
    delete result[key as keyof T];
  }
  return result;
}

/**
 * Check if an object has all required keys
 * @template T Type of object to check
 * @param obj Object to check
 * @param keys Required keys
 * @returns Whether all keys exist
 */
export function hasRequiredKeys<T extends object>(
  obj: T,
  keys: (keyof T)[]
): boolean {
  return keys.every((key) => 
    Object.prototype.hasOwnProperty.call(obj, key) && obj[key] !== undefined
  );
}
