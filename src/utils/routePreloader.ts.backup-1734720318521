export interface PreloadConfig;

export interface PreloadConfig;

/**
 * Configuration for route preloading
 */
export interface PreloadConfig {
  /** Routes to preload */
  routes: string[];
  /** Preloading priority */
  priority?: 'high' | 'low';
  /** Timeout for preloading in milliseconds */
  timeout?: number;
}

/**
 * Utility class for preloading routes
 */
export class RoutePreloader {
  /** Set of already preloaded routes */
  private preloadedRoutes: Set<string> = new Set();
  /** Intersection observer for viewport-based preloading */
  private observer: IntersectionObserver | null = null;
  /** Default timeout for preloading */
  private readonly DEFAULT_TIMEOUT = 5000;
  /** Default priority for preloading */
  private readonly DEFAULT_PRIORITY = 'low';

  constructor() {
    // Initialize intersection observer for viewport-based preloading
    if (typeof window !== 'undefined' && 'IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const route = entry.target.getAttribute('data-route');
              if (route) {
                void this.preloadRoute(route);
              }
            }
          });
        },
        { rootMargin: '50px' }
      );
    }
  }

  /**
   * Preload a single route
   * @param route Route to preload
   * @param priority Preloading priority
   * @param timeout Timeout in milliseconds
   * @returns Promise that resolves when preloading is complete
   */
  public async preloadRoute(
    route: string,
    priority: PreloadConfig['priority'] = this.DEFAULT_PRIORITY,
    timeout: number = this.DEFAULT_TIMEOUT
  ): Promise<void> {
    if (this.preloadedRoutes.has(route)) {
      return;
    }

    try {
      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), timeout);

      const link = document.createElement('link');
      link.rel = 'prefetch';
      link.href = route;
      link.as = 'document';
      link.importance = priority || this.DEFAULT_PRIORITY;

      document.head.appendChild(link);
      this.preloadedRoutes.add(route);

      window.clearTimeout(timeoutId);
    } catch (error) {
      console.warn(`Failed to preload route: ${route}`, error);
    }
  }

  /**
   * Preload multiple routes
   * @param config Preload configuration
   * @returns Promise that resolves when all routes are preloaded
   */
  public async preloadRoutes(config: PreloadConfig): Promise<void> {
    const { routes, priority, timeout } = config;
    await Promise.all(
      routes.map((route) => this.preloadRoute(route, priority, timeout))
    );
  }

  /**
   * Observe an element for viewport-based preloading
   * @param element Element to observe
   * @param route Route to preload when element is visible
   */
  public observeElement(element: Element, route: string): void {
    if (!this.observer) {
      console.warn('IntersectionObserver not supported');
      return;
    }

    element.setAttribute('data-route', route);
    this.observer.observe(element);
  }

  /**
   * Stop observing an element
   * @param element Element to stop observing
   */
  public unobserveElement(element: Element): void {
    if (!this.observer) {
      return;
    }

    this.observer.unobserve(element);
    element.removeAttribute('data-route');
  }

  /**
   * Clear all preloaded routes
   */
  public clear(): void {
    this.preloadedRoutes.clear();
  }

  /**
   * Clean up resources
   */
  public destroy(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    this.clear();
  }
}

// Create a singleton instance
export const routePreloader = new RoutePreloader();

export type { PreloadConfig };
