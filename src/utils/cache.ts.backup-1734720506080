import type { Region } from '../services/locations/regions';
import type { TimeSlot } from '../types';

export interface CacheEntry;
export interface CacheWarmingResult;

















/**
 * Represents a cache entry for time slots
 */

  /** Timestamp when the entry was cached */
  timestamp: number;
  /** Region associated with the slots */
  region: Region;
  /** Additional parameters used for caching */
  params: Record<string, unknown>;
}

/**
 * Result of a cache warming operation
 */

  /** Status of the warming operation */
  status: 'completed' | 'failed';
  /** Error message if warming failed */
  error?: string;
}

/**
 * Manages cache warming operations
 */
class CacheWarmer {
  private static instance: CacheWarmer;
  private warming = false;
  private queue: Array<() => Promise<void>> = [];
  private worker: Worker | null = null;
  private readonly maxRetries = 3;
  private readonly retryDelay = 1000;

  private constructor() {
    // Private constructor to enforce singleton
  }

  /**
   * Gets the singleton instance of CacheWarmer
   */
  public static getInstance(): CacheWarmer {
    if (!CacheWarmer.instance) {
      CacheWarmer.instance = new CacheWarmer();
    }
    return CacheWarmer.instance;
  }

  /**
   * Starts the cache warming process
   * @param region Region to warm cache for
   * @returns Promise that resolves when warming is complete
   */
  public async warmCache(region: Region): Promise<CacheWarmingResult> {
    if (this.warming) {
      return this.queueWarmingOperation(region);
    }

    try {
      this.warming = true;
      await this.startWorker();
      const result = await this.executeWarmingOperation(region);
      return result;
    } catch (error) {
      return {
        region,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    } finally {
      this.warming = false;
      this.processQueue();
    }
  }

  /**
   * Stops the cache warming process
   */
  public stopWarming(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.warming = false;
    this.queue = [];
  }

  /**
   * Checks if cache warming is in progress
   */
  public isWarming(): boolean {
    return this.warming;
  }

  /**
   * Gets the number of pending warming operations
   */
  public getPendingOperations(): number {
    return this.queue.length;
  }

  private async startWorker(): Promise<void> {
    if (this.worker) {
      return;
    }

    try {
      this.worker = new Worker(new URL('../workers/cacheWorker.ts', import.meta.url));
      await this.initializeWorker();
    } catch (error) {
      throw new Error('Failed to start cache worker: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }

  private async initializeWorker(): Promise<void> {
    if (!this.worker) {
      throw new Error('Worker not initialized');
    }

    return new Promise((resolve, reject) => {
      if (!this.worker) {
        reject(new Error('Worker not initialized'));
        return;
      }

      this.worker.onmessage = (event) => {
        if (event.data.type === 'initialized') {
          resolve();
        } else {
          reject(new Error('Worker initialization failed'));
        }
      };

      this.worker.onerror = (error) => {
        reject(new Error('Worker error: ' + error.message));
      };

      this.worker.postMessage({ type: 'initialize' });
    });
  }

  private async executeWarmingOperation(region: Region): Promise<CacheWarmingResult> {
    if (!this.worker) {
      throw new Error('Worker not initialized');
    }

    return new Promise((resolve, reject) => {
      if (!this.worker) {
        reject(new Error('Worker not initialized'));
        return;
      }

      let retryCount = 0;

      const retry = async () => {
        try {
          const result = await this.executeWithTimeout(region);
          resolve(result);
        } catch (error) {
          if (retryCount < this.maxRetries) {
            retryCount++;
            setTimeout(retry, this.retryDelay * Math.pow(2, retryCount));
          } else {
            resolve({
              region,
              status: 'failed',
              error: error instanceof Error ? error.message : 'Maximum retries exceeded'
            });
          }
        }
      };

      retry();
    });
  }

  private async executeWithTimeout(region: Region): Promise<CacheWarmingResult> {
    return new Promise((resolve, reject) => {
      const timeout = window.setTimeout(() => {
        reject(new Error('Cache warming operation timed out'));
      }, 30000);

      if (!this.worker) {
        window.clearTimeout(timeout);
        reject(new Error('Worker not initialized'));
        return;
      }

      this.worker.onmessage = (event) => {
        window.clearTimeout(timeout);
        if (event.data.type === 'complete') {
          resolve({
            region,
            status: 'completed'
          });
        } else if (event.data.type === 'error') {
          resolve({
            region,
            status: 'failed',
            error: event.data.error
          });
        }
      };

      this.worker.postMessage({
        type: 'warmCache',
        region
      });
    });
  }

  private async queueWarmingOperation(region: Region): Promise<CacheWarmingResult> {
    return new Promise((resolve) => {
      this.queue.push(async () => {
        const result = await this.warmCache(region);
        resolve(result);
      });
    });
  }

  private async processQueue(): Promise<void> {
    const next = this.queue.shift();
    if (next) {
      await next();
    }
  }
}

export { CacheWarmer, type CacheEntry, type CacheWarmingResult };

undefined.displayName = 'undefined';