export interface Coordinates;
export interface ServiceFeeConfig;

export interface Coordinates;
export interface ServiceFeeConfig;

/**
 * Geographic coordinates
 */
export interface Coordinates {
  /** Latitude in decimal degrees */
  latitude: number;
  /** Longitude in decimal degrees */
  longitude: number;
}

/**
 * Configuration for service fee calculation
 */
export interface ServiceFeeConfig {
  /** Base service fee amount */
  baseFee: number;
  /** Additional fee per kilometer */
  additionalFeePerKm: number;
  /** Distance covered by base fee (in km) */
  freeDistance: number;
}

const DEFAULT_CONFIG: ServiceFeeConfig = {
  baseFee: 50,
  additionalFeePerKm: 2,
  freeDistance: 5
};

/** Earth's radius in kilometers */
const EARTH_RADIUS_KM = 6371;

/**
 * Calculate the distance between two points using the Haversine formula
 * @param point1 First coordinate point
 * @param point2 Second coordinate point
 * @returns Distance in kilometers
 */
export function calculateDistance(point1: Coordinates, point2: Coordinates): number {
  const dLat = toRadians(point2.latitude - point1.latitude);
  const dLon = toRadians(point2.longitude - point1.longitude);

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(point1.latitude)) * Math.cos(toRadians(point2.latitude)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return EARTH_RADIUS_KM * c;
}

/**
 * Convert degrees to radians
 * @param degrees Angle in degrees
 * @returns Angle in radians
 */
export function toRadians(degrees: number): number {
  return degrees * (Math.PI / 180);
}

/**
 * Check if a location is within service range
 * @param serviceLocation Location to check
 * @param centerLocation Center of service area
 * @param maxDistance Maximum service distance in kilometers
 * @returns Whether the location is within service range
 */
export function isWithinServiceRange(
  serviceLocation: Coordinates,
  centerLocation: Coordinates,
  maxDistance: number
): boolean {
  const distance = calculateDistance(serviceLocation, centerLocation);
  return distance <= maxDistance;
}

/**
 * Calculate service fee based on distance
 * @param distance Distance in kilometers
 * @param config Service fee configuration
 * @returns Total service fee
 */
export function calculateServiceFee(
  distance: number,
  config: Partial<ServiceFeeConfig> = {}
): number {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };
  
  if (distance <= finalConfig.freeDistance) {
    return finalConfig.baseFee;
  }

  const extraDistance = distance - finalConfig.freeDistance;
  const additionalFee = extraDistance * finalConfig.additionalFeePerKm;
  
  return Math.round(finalConfig.baseFee + additionalFee);
}

/**
 * Format distance for display
 * @param distance Distance in kilometers
 * @returns Formatted distance string
 */
export function formatDistance(distance: number): string {
  if (distance < 1) {
    return `${Math.round(distance * 1000)}m`;
  }
  return `${distance.toFixed(1)}km`;
}

/**
 * Estimate travel time based on distance
 * @param distance Distance in kilometers
 * @param averageSpeed Average speed in km/h
 * @returns Estimated travel time in minutes
 */
export function estimateTravelTime(distance: number, averageSpeed = 30): number {
  return Math.round((distance / averageSpeed) * 60);
}

/**
 * Format travel time for display
 * @param minutes Travel time in minutes
 * @returns Formatted time string
 */
export function formatTravelTime(minutes: number): string {
  if (minutes < 60) {
    return `${minutes} min`;
  }

  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;

  if (remainingMinutes === 0) {
    return `${hours}h`;
  }

  return `${hours}h ${remainingMinutes}m`;
}

export type { Coordinates, ServiceFeeConfig };
