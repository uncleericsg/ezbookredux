import debounce from 'lodash/debounce';
import { MessageSquare, Mail, Bell } from 'lucide-react';
import { z } from 'zod';

import { TEMPLATE_TYPES } from '../constants/templateConstants';

export interface Template;
export interface TemplateVersion;
export type TemplateFormData;

export interface Template;
export interface TemplateVersion;
export type TemplateFormData;

export interface Template;
export interface TemplateVersion;
export type TemplateFormData;

export interface Template {
  id: string;
  name: string;
  content: string;
  version: number;
  lastModified: string;
  variables: string[];
  userType: string;
  type: keyof typeof TEMPLATE_TYPES;
  status?: string;
}

export interface TemplateVersion {
  id: string;
  templateId: string;
  content: string;
  version: number;
}

export const templateSchema = z.object({
  name: z.string().min(1, 'Template name is required').max(100),
  content: z.string()
    .min(1, 'Template content is required')
    .max(500)
    .refine((content) => {
      // Check for valid variable syntax
      const variableRegex = /\{\{[^{}]+\}\}/g;
      const variables = content.match(variableRegex);
      return variables !== null;
    }, 'Template must contain at least one valid variable'),
  type: z.enum(Object.keys(TEMPLATE_TYPES) as [string, ...string[]]),
  userType: z.string(),
  variables: z.array(z.string())
});

export type TemplateFormData = z.infer<typeof templateSchema>;

const validateTemplate = (template: Template) => {
  try {
    templateSchema.parse(template);
    return { valid: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { valid: false, errors: error.issues };
    }
    return { valid: false, errors: [{ message: 'Unknown error' }] };
  }
};

const getTemplateVariables = (content: string) => {
  const variableRegex = /\{\{([^{}]+)\}\}/g;
  const matches = content.matchAll(variableRegex);
  return Array.from(matches, (m) => m[1]);
};

const getTemplatePreview = (template: Template, variables: { [key: string]: string }) => {
  if (template.userType !== 'all' && template.userType !== variables.userType) {
    throw new Error('Template not available for this user type');
  }
  let preview = template.content;
  for (const [key, value] of Object.entries(variables)) {
    preview = preview.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }
  return preview;
};

const createAutosaveFunction = (saveFunction: (template: Partial<Template>) => Promise<void>, delay: number) => {
  return debounce(async (template: Partial<Template>) => {
    try {
      await saveFunction(template);
    } catch (error) {
      globalThis.console.error('Autosave failed: ', error);
      // Implement your error handling here
    }
  }, delay);
};

const getTemplateDiff = (oldContent: string, newContent: string) => {
  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');
  const changes: string[] = [];
  let i = 0;
  let j = 0;
  while (i < oldLines.length || j < newLines.length) {
    if (i >= oldLines.length) {
      changes.push(`+ ${newLines[j]}`);
      j++;
    } else if (j >= newLines.length) {
      changes.push(`- ${oldLines[i]}`);
      i++;
    } else if (oldLines[i] !== newLines[j]) {
      changes.push(`- ${oldLines[i]}`);
      changes.push(`+ ${newLines[j]}`);
      i++;
      j++;
    } else {
      i++;
      j++;
    }
  }
  return changes;
};

const getIconComponent = (type: keyof typeof TEMPLATE_TYPES) => {
  switch (type) {
    case TEMPLATE_TYPES.EMAIL:
      return Mail;
    case TEMPLATE_TYPES.PUSH:
      return Bell;
    default:
      return MessageSquare;
  }
};

const sortTemplates = (templates: Template[], sortBy: string) => {
  return [...templates].sort((a, b) => {
    switch (sortBy) {
      case 'title':
        return a.name.localeCompare(b.name);
      case 'type':
        return a.type.localeCompare(b.type);
      case 'status':
        return (a.status || '').localeCompare(b.status || '');
      case 'date':
      default:
        return new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime();
    }
  });
};

const filterTemplates = (templates: Template[], searchTerm: string) => {
  const term = searchTerm.toLowerCase();
  return templates.filter((template) => template.name.toLowerCase().includes(term) || template.content.toLowerCase().includes(term));
};

const templateUtils = null;

export {
  templateSchema,
  templateUtils,
  validateTemplate,
  getTemplateVariables,
  getTemplatePreview,
  createAutosaveFunction,
  getTemplateDiff,
  getIconComponent,
  sortTemplates,
  filterTemplates,
};
export default templateSchema;
