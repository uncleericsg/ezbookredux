'use client';

import { format, addMinutes, startOfDay } from 'date-fns';
import { motion } from 'framer-motion';
import { Loader2 } from 'lucide-react';
import React, { useCallback, useEffect, useState } from 'react';

import { BUSINESS_RULES } from '../../constants/businessRules';
import { CustomerInfo, PricingOption, TimeSlot } from '../../types/booking';
import { Calendar } from '../Calendar';

import styles from './ScheduleStep.module.css';

export type ReturnCustomerScheduleProps;





// Export types at the top

  selectedService: PricingOption;
  onScheduleSelect: (date: Date, timeSlot: TimeSlot) => void;
  onBack: () => void;
};

// Helper function to generate time slots
export const generateTimeSlots = (
  date: Date,
  startMinutes: number,
  endMinutes: number
): TimeSlot[] => {
  const slots: TimeSlot[] = [];
  for (let minutes = startMinutes; minutes < endMinutes; minutes += 30) {
    const time = addMinutes(date, minutes);
    const timeStr = format(time, 'HH:mm');
    const hour = time.getHours();
    const isPeakHour =
      hour >= BUSINESS_RULES.PEAK_HOURS.START && hour < BUSINESS_RULES.PEAK_HOURS.END;
    slots.push({
      time: timeStr,
      isPeakHour,
      available: true,
    });
  }
  return slots;
};

// Component declaration as const
const ReturnCustomerSchedule = ({
  customerInfo,
  selectedService,
  onScheduleSelect,
  onBack,
}: ReturnCustomerScheduleProps) => {
  const [selectedDate, setSelectedDate] = useState<Date>(startOfDay(new Date()));
  const [selectedTime, setSelectedTime] = useState<string>('');
  const [availableSlots, setAvailableSlots] = useState<TimeSlot[]>([]);
  const [loading, setLoading] = useState(false);

  // Simulate fetching available slots
  const fetchAvailableSlots = useCallback(
    async (date: Date) => {
      setLoading(true);
      try {
        // Simulating API call
        await new Promise((resolve) => {
          window.setTimeout(resolve, 1000);
        });

        // Use customer info and selected service to determine available slots
        const slots = generateTimeSlots(
          date,
          BUSINESS_RULES.OPERATING_HOURS.START * 60,
          BUSINESS_RULES.OPERATING_HOURS.END * 60
        );

        // Apply customer-specific and service-specific availability logic
        const adjustedSlots = slots.map((slot) => {
          const isPreferredCustomer = customerInfo.loyaltyLevel > 0;
          const hasServiceDiscount = selectedService.discountEligible && isPreferredCustomer;

          return {
            ...slot,
            available: Math.random() > (isPreferredCustomer ? 0.2 : 0.3), // Better availability for loyal customers
            isPeakHour: slot.isPeakHour && selectedService.peakHourSurcharge > 0,
            price: hasServiceDiscount ? selectedService.price * 0.9 : selectedService.price,
          };
        });

        setAvailableSlots(adjustedSlots);
      } catch (error) {
        console.error('Error fetching available slots:', error);
        setAvailableSlots([]);
      } finally {
        setLoading(false);
      }
    },
    [selectedService, customerInfo]
  );

  useEffect(() => {
    fetchAvailableSlots(selectedDate);
  }, [selectedDate, fetchAvailableSlots]);

  const handleDateSelect = (date: Date) => {
    setSelectedDate(date);
    setSelectedTime('');
  };

  const handleTimeSelect = (slot: TimeSlot) => {
    if (!slot.available) return;

    setSelectedTime(slot.time);
    const selectedDateTime = new Date(selectedDate);
    const [hours, minutes] = slot.time.split(':').map(Number);
    selectedDateTime.setHours(hours, minutes);
    onScheduleSelect(selectedDateTime, slot);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      className={styles.scheduleStep}
    >
      <div className={styles.calendar}>
        <Calendar
          selectedDate={selectedDate}
          onSelect={handleDateSelect}
          minDate={new Date()}
          className={styles.calendarComponent}
        />
      </div>

      <div className={styles.timeSlots}>
        <h3>Available Time Slots</h3>
        {loading ? (
          <div className={styles.loading}>
            <Loader2 className="h-6 w-6 animate-spin" />
            <span>Loading available slots...</span>
          </div>
        ) : (
          <div className={styles.slotGrid}>
            {availableSlots.map((slot) => (
              <button
                key={slot.time}
                onClick={() => handleTimeSelect(slot)}
                className={`${styles.timeSlot} ${
                  !slot.available ? styles.unavailable : ''
                } ${selectedTime === slot.time ? styles.selected : ''} ${
                  slot.isPeakHour ? styles.peakHour : ''
                }`}
                disabled={!slot.available}
              >
                <span>{slot.time}</span>
                {slot.isPeakHour && <span className={styles.peakLabel}>Peak</span>}
              </button>
            ))}
          </div>
        )}
      </div>

      <div className={styles.actions}>
        <button onClick={onBack} className={styles.backButton}>
          Back
        </button>
      </div>
    </motion.div>
  );
};

// Add displayName
ReturnCustomerSchedule.displayName = 'ReturnCustomerSchedule';

// Both named and default exports at the bottom
export { ReturnCustomerSchedule };


undefined.displayName = 'undefined';