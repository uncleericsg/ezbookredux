import * as React from 'react';

// Base error class for all location-related errors
export class LocationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'LocationError';
  }
}

// Specific error types
export class RegionNotFoundError extends LocationError {
  constructor(address: string) {
    super(`Unable to determine region for address: ${address}`);
    this.name = 'RegionNotFoundError';
  }
}

export class OptimizationError extends LocationError {
  readonly retryable: boolean;

  constructor(message: string, retryable: boolean = true) {
    super(message);
    this.retryable = retryable;
    this.name = 'OptimizationError';
  }
}

export class RateLimitError extends LocationError {
  readonly retryAfter: number;

  constructor(retryAfter: number) {
    super(`Rate limit exceeded. Please try again in ${retryAfter} seconds`);
    this.retryAfter = retryAfter;
    this.name = 'RateLimitError';
  }
}

export class NetworkTimeoutError extends LocationError {
  readonly offline: boolean;

  constructor(offline: boolean = false) {
    super(offline ? 'No internet connection' : 'Network request failed');
    this.offline = offline;
    this.name = 'NetworkTimeoutError';
  }
}

export class DataValidationError extends LocationError {
  readonly validationErrors: string[];

  constructor(validationErrors: string[]) {
    super('Validation failed: ' + validationErrors.join(', '));
    this.validationErrors = validationErrors;
    this.name = 'DataValidationError';
  }
}

// Error type guards
export function isLocationError(error: unknown): error is LocationError {
  return error instanceof LocationError;
}

export function isRateLimitError(error: unknown): error is RateLimitError {
  return error instanceof RateLimitError;
}

export function isNetworkTimeoutError(error: unknown): error is NetworkTimeoutError {
  return error instanceof NetworkTimeoutError;
}

export function isRetryableError(error: unknown): boolean {
  if (error instanceof OptimizationError) {
    return error.retryable;
  }
  if (error instanceof RateLimitError) {
    return true;
  }
  if (error instanceof NetworkTimeoutError) {
    return !error.offline;
  }
  return false;
}

// Application error interfaces
export interface BaseError {
  code: string;
  message: string;
  timestamp: Date;
  path?: string;
  stack?: string;
}

export interface ValidationError extends BaseError {
  field: string;
  value: unknown;
  constraints: Record<string, string>;
}

export interface NetworkError extends BaseError {
  status: number;
  url: string;
  method: string;
  response?: unknown;
}

export interface AuthError extends BaseError {
  userId?: string;
  action: 'login' | 'register' | 'reset' | 'verify';
  provider?: string;
}

export interface DatabaseError extends BaseError {
  table?: string;
  operation: 'create' | 'read' | 'update' | 'delete';
  details?: Record<string, unknown>;
}

export interface ServiceError extends BaseError {
  service: string;
  operation: string;
  details?: Record<string, unknown>;
}

export type AppError = 
  | ValidationError 
  | NetworkError 
  | AuthError 
  | DatabaseError 
  | ServiceError;

export interface ErrorState {
  errors: AppError[];
  hasError: boolean;
  lastError?: AppError;
}

export interface ErrorHandler {
  handleError: (error: AppError) => void;
  clearError: (code: string) => void;
  clearAllErrors: () => void;
  getError: (code: string) => AppError | undefined;
}

// Type guards for application errors
export const isValidationError = (error: AppError): error is ValidationError => {
  return 'field' in error && 'constraints' in error;
};

export const isNetworkError = (error: AppError): error is NetworkError => {
  return 'status' in error && 'url' in error;
};

export const isAuthError = (error: AppError): error is AuthError => {
  return 'action' in error;
};

export const isDatabaseError = (error: AppError): error is DatabaseError => {
  return 'operation' in error && 'table' in error;
};

export const isServiceError = (error: AppError): error is ServiceError => {
  return 'service' in error && 'operation' in error;
};