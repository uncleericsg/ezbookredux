import * as React from 'react';

export type guards;

export interface BaseError;

export interface ValidationError;

export interface NetworkError;

export interface AuthError;

export interface DatabaseError;

export interface ServiceError;

export type AppError;

export interface ErrorState;

export interface ErrorHandler;


// Base error class for all location-related errors
export class LocationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'LocationError';
  }
}

// Specific error types
export class RegionNotFoundError extends LocationError {
  constructor(address: string) {
    super(`Unable to determine region for address: ${address}`);
    this.name = 'RegionNotFoundError';
  }
}

export class OptimizationError extends LocationError {
  readonly retryable: boolean;

  constructor(message: string, retryable: boolean = true) {
    super(message);
    this.retryable = retryable;
    this.name = 'OptimizationError';
  }
}

export class RateLimitError extends LocationError {
  readonly retryAfter: number;

  constructor(retryAfter: number) {
    super(`Rate limit exceeded. Please try again in ${retryAfter} seconds`);
    this.retryAfter = retryAfter;
    this.name = 'RateLimitError';
  }
}

export class NetworkTimeoutError extends LocationError {
  readonly offline: boolean;

  constructor(offline: boolean = false) {
    super(offline ? 'No internet connection' : 'Network request failed');
    this.offline = offline;
    this.name = 'NetworkTimeoutError';
  }
}

export class DataValidationError extends LocationError {
  readonly validationErrors: string[];

  constructor(validationErrors: string[]) {
    super('Validation failed: ' + validationErrors.join(', '));
    this.validationErrors = validationErrors;
    this.name = 'DataValidationError';
  }
}

// Error type guards
export function isLocationError(error: unknown): error is LocationError {
  return error instanceof LocationError;
}

export function isRateLimitError(error: unknown): error is RateLimitError {
  return error instanceof RateLimitError;
}

export function isNetworkTimeoutError(error: unknown): error is NetworkTimeoutError {
  return error instanceof NetworkTimeoutError;
}

export function isRetryableError(error: unknown): boolean {
  if (error instanceof OptimizationError) {
    return error.retryable;
  }
  if (error instanceof RateLimitError) {
    return true;
  }
  if (error instanceof NetworkTimeoutError) {
    return !error.offline;
  }
  return false;
}

// Application error interfaces

  message: string;
  timestamp: Date;
  path?: string;
  stack?: string;
}

  value: unknown;
  constraints: Record<string, string>;
}

  url: string;
  method: string;
  response?: unknown;
}

  action: 'login' | 'register' | 'reset' | 'verify';
  provider?: string;
}

  operation: 'create' | 'read' | 'update' | 'delete';
  details?: Record<string, unknown>;
}

  operation: string;
  details?: Record<string, unknown>;
}

  hasError: boolean;
  lastError?: AppError;
}

  clearError: (code: string) => void;
  clearAllErrors: () => void;
  getError: (code: string) => AppError | undefined;
}

// Type guards for application errors
export const isValidationError = (error: AppError): error is ValidationError => {
  return 'field' in error && 'constraints' in error;
};

export const isNetworkError = (error: AppError): error is NetworkError => {
  return 'status' in error && 'url' in error;
};

export const isAuthError = (error: AppError): error is AuthError => {
  return 'action' in error;
};

export const isDatabaseError = (error: AppError): error is DatabaseError => {
  return 'operation' in error && 'table' in error;
};

export const isServiceError = (error: AppError): error is ServiceError => {
  return 'service' in error && 'operation' in error;
};
undefined.displayName = 'undefined';