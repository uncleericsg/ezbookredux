import { addDays, differenceInDays } from 'date-fns';

import { supabase } from '@/lib/supabase';
import { ServiceContract, ContractStatus, OverduePeriod, ServiceReminder } from '@/types/contract';

export interface ServiceMetrics;

export interface ServiceMetrics;

export interface ServiceMetrics;


interface ServiceMetrics {
  totalContracts: number;
  overdueContracts: {
    '1-30': number;
    '31-60': number;
    '60+': number;
  };
  completionRate: number;
}

/**
 * Service for managing service contracts
 */
export class ContractService {
  private static instance: ContractService;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): ContractService {
    if (!ContractService.instance) {
      ContractService.instance = new ContractService();
    }
    return ContractService.instance;
  }

  /**
   * Get all service contracts
   * @returns List of service contracts
   */
  public async getContracts(): Promise<ServiceContract[]> {
    const { data, error } = await supabase
      .from('service_contracts')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) throw error;

    return data.map(contract => ({
      ...contract,
      overdueStatus: this.calculateOverdueStatus(contract.nextService)
    }));
  }

  /**
   * Calculate overdue status based on next service date
   * @param nextService Next service date
   * @returns Overdue period category
   */
  private calculateOverdueStatus(nextService?: Date): OverduePeriod {
    if (!nextService) return 'all';

    const daysOverdue = differenceInDays(new Date(), new Date(nextService));
    if (daysOverdue <= 0) return 'all';
    if (daysOverdue <= 30) return '1-30';
    if (daysOverdue <= 60) return '31-60';
    return '60+';
  }

  /**
   * Block a contract
   * @param contractId Contract ID
   * @param reason Block reason
   */
  public async blockContract(contractId: string, reason: string): Promise<void> {
    const { error } = await supabase
      .from('service_contracts')
      .update({ 
        isBlocked: true,
        blockReason: reason,
        status: 'blocked' as ContractStatus
      })
      .eq('id', contractId);

    if (error) throw error;
  }

  /**
   * Unblock a contract
   * @param contractId Contract ID
   */
  public async unblockContract(contractId: string): Promise<void> {
    const { error } = await supabase
      .from('service_contracts')
      .update({ 
        isBlocked: false,
        blockReason: null,
        status: 'active' as ContractStatus
      })
      .eq('id', contractId);

    if (error) throw error;
  }

  /**
   * Send service reminder
   * @param contractId Contract ID
   */
  public async sendReminder(contractId: string): Promise<void> {
    const { data: contract, error: contractError } = await supabase
      .from('service_contracts')
      .select('*')
      .eq('id', contractId)
      .single();

    if (contractError) throw contractError;

    const reminder: Partial<ServiceReminder> = {
      contractId,
      userId: contract.userId,
      message: `Your next service is due on ${new Date(contract.nextService).toLocaleDateString()}`
    };

    const { error: reminderError } = await supabase
      .from('service_reminders')
      .insert(reminder);

    if (reminderError) throw reminderError;
  }

  /**
   * Update service dates for a contract
   * @param contractId Contract ID
   */
  public async updateServiceDates(contractId: string): Promise<void> {
    const { data: contract, error: contractError } = await supabase
      .from('service_contracts')
      .select('*')
      .eq('id', contractId)
      .single();

    if (contractError) throw contractError;

    const nextService = addDays(new Date(), 90); // 90-day cycle for AMC
    const { error: updateError } = await supabase
      .from('service_contracts')
      .update({ 
        lastService: new Date().toISOString(),
        nextService: nextService.toISOString(),
        servicesCompleted: (contract.servicesCompleted || 0) + 1
      })
      .eq('id', contractId);

    if (updateError) throw updateError;
  }

  /**
   * Check for expiring contracts and send reminders
   */
  public async checkExpiringContracts(): Promise<void> {
    const expiryWarningDays = 110; // Send reminder 110 days before expiry
    const today = new Date();

    const { data: contracts, error } = await supabase
      .from('service_contracts')
      .select('*')
      .eq('status', 'active');

    if (error) throw error;

    for (const contract of contracts) {
      const daysUntilExpiry = differenceInDays(
        new Date(contract.endDate),
        today
      );

      if (daysUntilExpiry <= expiryWarningDays && daysUntilExpiry > 0) {
        // Update contract status to expiring
        await supabase
          .from('service_contracts')
          .update({ status: 'expiring' as ContractStatus })
          .eq('id', contract.id);

        // Create expiry reminder
        const reminder: Partial<ServiceReminder> = {
          contractId: contract.id,
          userId: contract.userId,
          message: `Your AMC contract will expire in ${daysUntilExpiry} days. Please standby for renewal.`
        };

        await supabase
          .from('service_reminders')
          .insert(reminder);
      }
    }
  }

  /**
   * Get service metrics
   * @param _days Number of days to analyze
   * @returns Service metrics
   */
  public async getServiceMetrics(_days = 30): Promise<ServiceMetrics> {
    const { data: contracts, error } = await supabase
      .from('service_contracts')
      .select('*');

    if (error) throw error;

    const metrics: ServiceMetrics = {
      totalContracts: contracts.length,
      overdueContracts: {
        '1-30': contracts.filter(c => this.calculateOverdueStatus(c.nextService) === '1-30').length,
        '31-60': contracts.filter(c => this.calculateOverdueStatus(c.nextService) === '31-60').length,
        '60+': contracts.filter(c => this.calculateOverdueStatus(c.nextService) === '60+').length
      },
      completionRate: this.calculateCompletionRate(contracts)
    };

    return metrics;
  }

  /**
   * Calculate service completion rate
   * @param contracts List of contracts
   * @returns Completion rate percentage
   */
  private calculateCompletionRate(contracts: ServiceContract[]): number {
    const activeContracts = contracts.filter(c => c.status === 'active');
    if (activeContracts.length === 0) return 0;

    const totalRequired = activeContracts.reduce((sum, c) => sum + c.servicesRequired, 0);
    const totalCompleted = activeContracts.reduce((sum, c) => sum + c.servicesCompleted, 0);
    return (totalCompleted / totalRequired) * 100;
  }

  /**
   * Calculate average response time for reminders
   * @param days Number of days to analyze
   * @returns Average response time in days
   */
  public async calculateAverageResponseTime(days: number): Promise<number> {
    const startDate = addDays(new Date(), -days);

    const { data: reminders, error } = await supabase
      .from('service_reminders')
      .select('*')
      .gte('sentDate', startDate.toISOString());

    if (error) throw error;

    const respondedReminders = reminders.filter(r => 
      r.status === 'viewed' || r.status === 'clicked'
    );

    if (respondedReminders.length === 0) return 0;

    const totalResponseTime = respondedReminders.reduce((sum, r) => {
      const responseTime = differenceInDays(
        new Date(r.viewedDate || r.clickedDate),
        new Date(r.sentDate)
      );
      return sum + responseTime;
    }, 0);

    return totalResponseTime / respondedReminders.length;
  }
}