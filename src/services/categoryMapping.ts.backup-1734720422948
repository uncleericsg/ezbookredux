import { toast } from 'sonner';
import { z } from 'zod';

import type { ServiceCategory } from '../types';

export interface AppointmentType;
export interface CategoryMap;
export type const;
export type appointmentTypeSchema;
export type details;
export type ID;
export type mapped;

export interface AppointmentType;
export interface CategoryMap;
export type const;
export type appointmentTypeSchema;
export type details;
export type ID;
export type mapped;

export interface AppointmentType;
export interface CategoryMap;
export type const;
export type appointmentTypeSchema;
export type details;
export type ID;
export type mapped;

interface AppointmentType {
  id: string;
  name: string;
  duration: number;
  category: string;
  availability: {
    startTime: string;
    endTime: string;
  };
}

interface CategoryMap {
  categoryId: string;
  appointmentTypeId: string;
  inheritFromParent?: boolean;
}

// Validation schema for appointment type
const appointmentTypeSchema = z.object({
  id: z.string(),
  name: z.string(),
  duration: z.number(),
  category: z.string(),
  availability: z.object({
    startTime: z.string(),
    endTime: z.string()
  })
});

/**
 * Singleton class for mapping service categories to appointment types
 */
export class CategoryMapper {
  private static instance: CategoryMapper;
  private readonly mappings: Map<string, string>;
  private readonly parentMappings: Map<string, string>;
  private readonly appointmentTypes: Map<string, AppointmentType>;

  private constructor() {
    this.mappings = new Map();
    this.parentMappings = new Map();
    this.appointmentTypes = new Map();

    // Set up default mappings for development mode
    if (import.meta.env.MODE === 'development') {
      const defaultTypes: AppointmentType[] = [
        {
          id: 'type1',
          name: 'Standard Service',
          duration: 60,
          category: 'maintenance',
          availability: {
            startTime: '09:00',
            endTime: '17:00'
          }
        },
        {
          id: 'type2',
          name: 'Deep Clean',
          duration: 120,
          category: 'cleaning',
          availability: {
            startTime: '09:00',
            endTime: '16:00'
          }
        }
      ];

      defaultTypes.forEach(type => {
        this.appointmentTypes.set(type.id, type);
        this.mappings.set(type.category, type.id);
      });
    }
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): CategoryMapper {
    if (!CategoryMapper.instance) {
      CategoryMapper.instance = new CategoryMapper();
    }
    return CategoryMapper.instance;
  }

  /**
   * Map a service category to an appointment type
   * @param category Service category
   * @param appointmentType Appointment type
   */
  public mapCategoryToAppointmentType(
    category: ServiceCategory,
    appointmentType: AppointmentType
  ): void {
    try {
      // Validate appointment type
      appointmentTypeSchema.parse(appointmentType);

      // Store appointment type details
      this.appointmentTypes.set(appointmentType.id, appointmentType);

      // Store mapping
      this.mappings.set(category.id, appointmentType.id);

      // If category has parent, store parent mapping
      if (category.parentId) {
        this.parentMappings.set(category.id, category.parentId);
      }
    } catch (error) {
      console.error('Invalid appointment type:', error);
      toast.error('Failed to map category to appointment type');
      throw error;
    }
  }

  /**
   * Get appointment type ID for a category
   * @param categoryId Category ID
   * @returns Appointment type ID or null if not found
   */
  public getAppointmentTypeId(categoryId: string): string | null {
    // Check direct mapping first
    const directMapping = this.mappings.get(categoryId);
    if (directMapping) return directMapping;

    // Check parent mapping if exists
    const parentId = this.parentMappings.get(categoryId);
    if (parentId) {
      return this.mappings.get(parentId) ?? null;
    }

    return null;
  }

  /**
   * Get appointment type details for a category
   * @param categoryId Category ID
   * @returns Appointment type details or null if not found
   */
  public getAppointmentTypeDetails(categoryId: string): AppointmentType | null {
    const appointmentTypeId = this.getAppointmentTypeId(categoryId);
    return appointmentTypeId ? this.appointmentTypes.get(appointmentTypeId) ?? null : null;
  }

  /**
   * Validate mapping exists for a category
   * @param categoryId Category ID
   * @returns True if mapping exists
   */
  public validateMapping(categoryId: string): boolean {
    const appointmentTypeId = this.getAppointmentTypeId(categoryId);
    if (!appointmentTypeId) {
      console.warn(`No appointment type mapped for category ${categoryId}`);
      return false;
    }
    return true;
  }

  /**
   * Clear mapping for a category
   * @param categoryId Category ID
   */
  public clearMapping(categoryId: string): void {
    this.mappings.delete(categoryId);
    this.parentMappings.delete(categoryId);
  }

  /**
   * Get all category mappings
   * @returns Array of category mappings
   */
  public getAllMappings(): CategoryMap[] {
    return Array.from(this.mappings.entries()).map(([categoryId, appointmentTypeId]) => ({
      categoryId,
      appointmentTypeId,
      inheritFromParent: this.parentMappings.has(categoryId)
    }));
  }
}

export type { AppointmentType, CategoryMap };