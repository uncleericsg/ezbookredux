import { Loader } from '@googlemaps/js-api-loader';
import * as React from 'react';

export class GooglePlacesService {
  private static instance: GooglePlacesService;
  private static loader: Loader | null = null;
  private autocompleteService: google.maps.places.AutocompleteService | null = null;
  private placesService: google.maps.places.PlacesService | null = null;
  private geocoder: google.maps.Geocoder | null = null;
  private isInitialized = false;
  private initializationPromise: Promise<void> | null = null;
  private dummyDiv: HTMLDivElement | null = null;
  private static readonly retryDelay = 1000; // 1 second delay between retries
  private static readonly maxRetries = 3;

  private constructor() {}

  public static getInstance(): GooglePlacesService {
    if (!GooglePlacesService.instance) {
      GooglePlacesService.instance = new GooglePlacesService();
    }
    return GooglePlacesService.instance;
  }

  private static getLoader(): Loader {
    if (!GooglePlacesService.loader) {
      GooglePlacesService.loader = new Loader({
        apiKey: process.env.GOOGLE_MAPS_API_KEY || '',
        version: 'weekly',
        libraries: ['places']
      });
    }
    return GooglePlacesService.loader;
  }

  private async loadGoogleMapsScript(): Promise<void> {
    try {
      await GooglePlacesService.getLoader().load();
    } catch (error) {
      console.error('Failed to load Google Maps script:', error);
      throw error;
    }
  }

  private createDummyElement(): void {
    if (!this.dummyDiv) {
      this.dummyDiv = document.createElement('div');
      this.dummyDiv.style.display = 'none';
      document.body.appendChild(this.dummyDiv);
    }
  }

  private cleanup(): void {
    if (this.dummyDiv) {
      document.body.removeChild(this.dummyDiv);
      this.dummyDiv = null;
    }
    this.autocompleteService = null;
    this.placesService = null;
    this.geocoder = null;
    this.isInitialized = false;
    this.initializationPromise = null;
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) return;
    if (this.initializationPromise) return this.initializationPromise;

    this.initializationPromise = (async () => {
      try {
        await this.loadGoogleMapsScript();
        this.createDummyElement();

        if (!this.dummyDiv) throw new Error('Failed to create dummy element');

        this.autocompleteService = new google.maps.places.AutocompleteService();
        this.placesService = new google.maps.places.PlacesService(this.dummyDiv);
        this.geocoder = new google.maps.Geocoder();
        this.isInitialized = true;
      } catch (error) {
        this.cleanup();
        throw error;
      }
    })();

    return this.initializationPromise;
  }

  private async retryOperation<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error | null = null;
    for (let attempt = 0; attempt < GooglePlacesService.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        if (!this.isRateLimitError(lastError)) throw error;
        await new Promise(resolve => setTimeout(resolve, GooglePlacesService.retryDelay * Math.pow(2, attempt)));
      }
    }
    throw lastError;
  }

  private isRateLimitError(error: Error): boolean {
    return error.message.includes('OVER_QUERY_LIMIT') ||
           error.message.includes('rate limit exceeded');
  }

  public async searchAddress(input: string): Promise<google.maps.places.AutocompletePrediction[]> {
    await this.initialize();
    if (!this.autocompleteService) throw new Error('Autocomplete service not initialized');

    return this.retryOperation(async () => {
      const response = await this.autocompleteService!.getPlacePredictions({
        input,
        componentRestrictions: { country: 'SG' },
        types: ['address']
      });
      return response.predictions;
    });
  }

  public async getPlaceDetails(placeId: string): Promise<google.maps.places.PlaceResult> {
    await this.initialize();
    if (!this.placesService) throw new Error('Places service not initialized');

    return new Promise((resolve, reject) => {
      this.placesService!.getDetails(
        { placeId, fields: ['address_components', 'formatted_address', 'geometry'] },
        (result, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK && result) {
            resolve(result);
          } else {
            reject(new Error(`Place details request failed: ${status}`));
          }
        }
      );
    });
  }

  public async getPostalCodeFromAddress(address: string): Promise<string | null> {
    await this.initialize();
    if (!this.geocoder) throw new Error('Geocoder not initialized');

    return this.retryOperation(async () => {
      const response = await this.geocoder!.geocode({ address });
      if (response.results.length === 0) return null;

      const postalComponent = response.results[0].address_components
        .find(component => component.types.includes('postal_code'));
      return postalComponent ? postalComponent.long_name : null;
    });
  }
}