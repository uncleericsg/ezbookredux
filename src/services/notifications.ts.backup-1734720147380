import axios from 'axios';
import { addDays } from 'date-fns';
import { toast } from 'sonner';

import { fetchPublicHolidays } from './publicHolidays';
import { getUserDetails } from './users';

import type { Notification, HolidayGreeting, PushTemplate } from '../types';

/**
 * Fetch notifications for the current user
 * @returns Array of notifications
 */
export const fetchNotifications = async (): Promise<Notification[]> => {
  try {
    const response = await axios.get<Notification[]>('/api/notifications');
    return response.data;
  } catch (error) {
    console.error('Error fetching notifications:', error);
    return [];
  }
};

/**
 * Validate template content
 * @param content Template content to validate
 * @returns True if content is valid
 */
const validateTemplateContent = (content: string): boolean => {
  if (!content.trim()) return false;
  if (content.length > 4096) return false;

  // Check for required placeholders
  const requiredPlaceholders = ['{first_name}'];
  return requiredPlaceholders.every((p) => content.includes(p));
};

/**
 * Validate URL format
 * @param url URL to validate
 * @returns True if URL is valid
 */
const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

/**
 * Validate push notification template
 * @param template Template to validate
 * @returns True if template is valid
 */
export const validatePushTemplate = (template: PushTemplate): boolean => {
  // Validate required fields
  if (!template.title?.trim()) {
    toast.error('Template title is required');
    return false;
  }

  if (!validateTemplateContent(template.content)) {
    toast.error('Invalid template content. Must include {first_name} placeholder');
    return false;
  }

  // Validate URL if present
  if (template.url && !isValidUrl(template.url)) {
    toast.error('Invalid action URL format');
    return false;
  }

  // Validate media URLs if present
  if (template.media?.image && !isValidUrl(template.media.image)) {
    toast.error('Invalid image URL');
    return false;
  }

  if (template.media?.video && !isValidUrl(template.media.video)) {
    toast.error('Invalid video URL');
    return false;
  }

  // Validate schedule if present
  if (template.schedule) {
    const { startDate, endDate } = template.schedule;
    if (startDate && endDate && new Date(startDate) > new Date(endDate)) {
      toast.error('End date must be after start date');
      return false;
    }
  }

  return true;
};

/**
 * Send notification to a specific user
 * @param userId User ID
 * @param templateId Template ID
 * @param data Additional data
 */
export const sendNotification = async (
  userId: string,
  templateId: string,
  data: Record<string, unknown>
): Promise<void> => {
  try {
    if (import.meta.env.DEV) {
       
      console.log('Would send notification: ', { userId, templateId, data });
      return;
    }

    await axios.post('/api/notifications/send', {
      userId,
      templateId,
      data
    });
  } catch (error) {
    console.error('Error sending notification:', error);
    throw error;
  }
};

/**
 * Fetch user notifications
 * @param userId User ID
 * @returns Array of notifications
 */
export const fetchUserNotifications = async (userId: string): Promise<Notification[]> => {
  if (import.meta.env.DEV) {
    return [
      {
        id: 'mock-notification',
        title: 'Mock Notification',
        message: 'This is a mock notification',
        type: 'info',
        read: false,
        createdAt: new Date().toISOString()
      }
    ];
  }

  try {
    const response = await axios.get(`/api/notifications/${userId}`);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch notifications: ', error);
    return [];
  }
};

/**
 * Mark notification as read
 * @param notificationId Notification ID
 */
export const markNotificationAsRead = async (notificationId: string): Promise<void> => {
  try {
    await axios.post(`/api/notifications/${notificationId}/read`);
  } catch (error) {
    console.error('Failed to mark notification as read: ', error);
    throw error;
  }
};

/**
 * Format date in a user-friendly way
 * @param dateString Date string to format
 * @returns Formatted date string
 */
export const formatDate = (dateString?: string): string => {
  if (!dateString) return '';

  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric'
    });
  } catch (error) {
    console.error('Failed to format date: ', error);
    return dateString;
  }
};

/**
 * Schedule reminder for a specific user
 * @param userId User ID
 * @param date Reminder date
 */
export const scheduleReminder = async (
  userId: string,
  date: Date
): Promise<void> => {
  try {
    const user = await getUserDetails(userId);
    const isAmc = user.lastName.toLowerCase().includes('amc');
    const reminderDays = isAmc ? 75 : 90;
    const reminderDate = addDays(date, -reminderDays);

    await axios.post('/api/notifications/schedule', {
      userId,
      date: reminderDate.toISOString(),
      metadata: {
        intervalDays: reminderDays
      }
    });

    if (isAmc) {
      // Schedule urgent reminder for AMC customers
      const urgentReminderDate = addDays(date, -30);
      await axios.post('/api/notifications/schedule', {
        userId,
        date: urgentReminderDate.toISOString(),
        metadata: {
          intervalDays: 30,
          isUrgent: true
        }
      });
    }
  } catch (error) {
    console.error('Failed to schedule reminder: ', error);
    throw error;
  }
};

/**
 * Schedule custom message for a specific user
 * @param schedule Schedule configuration
 */
export const scheduleCustomMessage = async (schedule: {
  message: string;
  scheduledDate: string;
  userType: 'all' | 'amc' | 'regular';
}): Promise<void> => {
  if (import.meta.env.DEV) {
    await new Promise((resolve) => globalThis.setTimeout(resolve, 1000));
     
    console.log('Would schedule message: ', schedule);
    return;
  }

  try {
    await axios.post('/api/notifications/schedule-custom', schedule);
  } catch (error) {
    console.error('Failed to schedule custom message: ', error);
    throw error;
  }
};

/**
 * Fetch holiday greetings
 * @returns Array of holiday greetings
 */
export const fetchHolidayGreetings = async (): Promise<HolidayGreeting[]> => {
  const publicHolidays = await fetchPublicHolidays();
  if (import.meta.env.DEV) {
    return publicHolidays.map((holiday) => ({
      id: `mock-holiday-${holiday.date}`,
      message: `Happy ${holiday.name}! Our office will be closed on ${new Date(
        holiday.date
      ).toLocaleDateString()}. For emergencies, please contact 9187 4498.`,
      enabled: true,
      sendTime: `${holiday.date}T09:00:00.000Z`
    }));
  }

  try {
    const response = await axios.get('/api/notifications/holiday-greetings');
    return response.data;
  } catch (error) {
    console.error('Failed to fetch holiday greetings: ', error);
    throw error;
  }
};

/**
 * Update holiday greeting
 * @param greeting Holiday greeting to update
 * @returns Updated greeting
 */
export const updateHolidayGreeting = async (
  greeting: HolidayGreeting
): Promise<HolidayGreeting> => {
  if (import.meta.env.DEV) {
    await new Promise((resolve) => globalThis.setTimeout(resolve, 1000));
    return {
      ...greeting,
      lastModified: new Date().toISOString()
    };
  }

  try {
    const response = await axios.put(
      `/api/notifications/holiday-greetings/${greeting.id}`,
      greeting
    );
    return response.data;
  } catch (error) {
    console.error('Failed to update holiday greeting: ', error);
    throw error;
  }
};

/**
 * Delete holiday greeting
 * @param id Holiday greeting ID
 */
export const deleteHolidayGreeting = async (id: string): Promise<void> => {
  if (import.meta.env.DEV) {
    await new Promise((resolve) => globalThis.setTimeout(resolve, 500));
    return;
  }

  try {
    await axios.delete(`/api/notifications/holiday-greetings/${id}`);
  } catch (error) {
    console.error('Failed to delete holiday greeting: ', error);
    throw error;
  }
};

/**
 * Send booking update notification
 * @param notification Notification configuration
 */
export const sendBookingUpdateNotification = async (notification: {
  userId: string;
  bookingId: string;
  type: 'booking_rescheduled' | 'booking_cancelled' | 'booking_confirmed';
  oldDateTime?: string;
  newDateTime?: string;
  isAdminAction?: boolean;
}): Promise<void> => {
  try {
    if (import.meta.env.DEV) {
      await new Promise((resolve) => globalThis.setTimeout(resolve, 1000));
       
      console.log('Would send booking update notification: ', notification);
      return;
    }

    const message = notification.isAdminAction
      ? `Your booking has been rescheduled by our admin team from ${formatDate(
          notification.oldDateTime
        )} to ${formatDate(notification.newDateTime)}.`
      : `Your booking has been successfully rescheduled from ${formatDate(
          notification.oldDateTime
        )} to ${formatDate(notification.newDateTime)}.`;

    await sendNotification(notification.userId, 'booking_update', {
      title: 'Booking Update',
      message,
      actionUrl: `/bookings/${notification.bookingId}`,
      metadata: {
        bookingId: notification.bookingId,
        type: notification.type
      }
    });

    // Send immediate toast notification if user is currently on the site
    toast.success('Booking Rescheduled', {
      description: message,
      action: {
        label: 'View Booking',
        onClick: () => {
          window.location.href = `/bookings/${notification.bookingId}`;
        }
      }
    });
  } catch (error) {
    console.error('Failed to send reschedule notification: ', error);
    throw error;
  }
};

/**
 * Send service-related notification
 * @param notification Service notification details
 */
export const sendServiceNotification = async (notification: {
  userId: string;
  serviceId: string;
  type: 'service_scheduled' | 'service_started' | 'service_completed' | 'service_cancelled';
  scheduledDate?: string;
  notes?: string;
}): Promise<void> => {
  try {
    const user = await getUserDetails(notification.userId);
    
    // Prepare notification message based on type
    let message = '';
    switch (notification.type) {
      case 'service_scheduled':
        message = `Your service visit has been scheduled for ${formatDate(notification.scheduledDate)}`;
        break;
      case 'service_started':
        message = 'Your service visit has started';
        break;
      case 'service_completed':
        message = 'Your service visit has been completed';
        break;
      case 'service_cancelled':
        message = 'Your service visit has been cancelled';
        break;
    }

    if (notification.notes) {
      message += `\nNotes: ${notification.notes}`;
    }

    await sendNotification(notification.userId, 'service_update', {
      message,
      serviceId: notification.serviceId,
      type: notification.type,
      scheduledDate: notification.scheduledDate
    });

    toast.success('Service notification sent successfully');
  } catch (error) {
    console.error('Error sending service notification:', error);
    toast.error('Failed to send service notification');
    throw error;
  }
};
