import { addMinutes } from 'date-fns';

import { validateBookingTime } from '../../utils/validation';

import { REGION_PRIORITY, type Region } from './regions';

import type { TimeSlot, Booking } from '../../types';

export type Region;
export interface OptimizerOptions;

const BUFFER_MINUTES = 60;
const NEARBY_BOOKING_PENALTY = 0.5;
const MAX_OVERLAPPING_SLOTS = 2;
const MAX_SLOTS_PER_REGION = 3;
const PEAK_HOUR_PENALTY = 0.8;

interface OptimizerOptions {
  holidays?: Set<string>;
  isAMC?: boolean;
  maxSlotsPerRegion?: number;
}

const getOverlappingBookings = (slot: TimeSlot, existingBookings: Booking[]): number => {
  const slotEnd = addMinutes(new Date(slot.datetime), BUFFER_MINUTES);
  const bufferedStart = addMinutes(new Date(slot.datetime), -BUFFER_MINUTES);
  const bufferedEnd = addMinutes(slotEnd, BUFFER_MINUTES);

  return existingBookings.filter(booking => {
    const bookingTime = new Date(booking.datetime);
    const bookingEnd = addMinutes(bookingTime, BUFFER_MINUTES);
    const isOverlapping = (
      (bookingTime >= bufferedStart && bookingTime <= bufferedEnd) ||
      (bookingEnd >= bufferedStart && bookingEnd <= bufferedEnd)
    );
    return isOverlapping;
  }).length;
};

export const optimizer = (
  slots: TimeSlot[],
  date: Date,
  region: Region,
  existingBookings: Booking[],
  options: OptimizerOptions = {}
): TimeSlot[] => {
  const {
    holidays = new Set(),
    isAMC = false,
    maxSlotsPerRegion = MAX_SLOTS_PER_REGION
  } = options;

  // Early return for empty slots
  if (!slots.length) return [];

  const dayOfWeek = date.getDay();
  if (dayOfWeek === 0 || dayOfWeek === 6) return [];

  const dateStr = date.toISOString().split('T')[0];
  if (holidays.has(dateStr)) return [];

  const regionPriority = REGION_PRIORITY[dayOfWeek];
  if (!regionPriority) return slots;

  const regionIndex = regionPriority.indexOf(region);
  const regionWeight = regionPriority.length - regionIndex;

  // Track slots per region
  const slotsPerRegion = new Map<Region, number>();

  // Filter and validate slots with business rules
  const validSlots = slots.filter(slot => {
    // Validate against business rules
    const validation = validateBookingTime(slot.datetime, isAMC);
    if (!validation.isValid) return false;

    // Check overlapping slots
    const overlappingCount = getOverlappingBookings(slot, existingBookings);
    if (overlappingCount >= MAX_OVERLAPPING_SLOTS) return false;

    // Check region capacity
    const slotRegion = region;
    const currentCount = slotsPerRegion.get(slotRegion) || 0;
    if (currentCount >= maxSlotsPerRegion) return false;

    slotsPerRegion.set(slotRegion, currentCount + 1);
    return true;
  });

  // Sort slots by score (higher score = better slot)
  return validSlots.sort((a, b) => {
    const timeA = new Date(a.datetime);
    const timeB = new Date(b.datetime);

    // Morning slots get higher weight
    const morningWeightA = timeA.getHours() < 12 ? 1.2 : 1;
    const morningWeightB = timeB.getHours() < 12 ? 1.2 : 1;

    // Peak hour penalty
    const peakPenaltyA = timeA.getHours() >= 17 ? PEAK_HOUR_PENALTY : 1;
    const peakPenaltyB = timeB.getHours() >= 17 ? PEAK_HOUR_PENALTY : 1;

    // Overlapping bookings penalty
    const overlappingA = getOverlappingBookings(a, existingBookings) * NEARBY_BOOKING_PENALTY;
    const overlappingB = getOverlappingBookings(b, existingBookings) * NEARBY_BOOKING_PENALTY;

    const scoreA = morningWeightA * peakPenaltyA * (1 - overlappingA) * regionWeight;
    const scoreB = morningWeightB * peakPenaltyB * (1 - overlappingB) * regionWeight;

    return scoreB - scoreA;
  });
};

export {
  BUFFER_MINUTES,
  NEARBY_BOOKING_PENALTY,
  MAX_OVERLAPPING_SLOTS,
  MAX_SLOTS_PER_REGION,
  PEAK_HOUR_PENALTY
};