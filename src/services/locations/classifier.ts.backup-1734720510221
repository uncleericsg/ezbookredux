import { LRUCache } from 'lru-cache';
import * as React from 'react';
import { toast } from 'sonner';
import { z } from 'zod';

import { REGION_CENTERS, type Region } from './regions';

export type Region;
export type Address;









// Validation schemas
const addressSchema = z.object({
  street: z.string(),
  postalCode: z.string().regex(/^[0-9]{6}$/, 'Invalid postal code format'),
  unit: z.string().optional()
});

type Address = z.infer<typeof addressSchema>;

// LRU Cache configuration
const cache = new LRUCache<string, Region>({
  max: 500, // Store up to 500 entries
  ttl: 1000 * 60 * 60, // 1 hour TTL
  updateAgeOnGet: true
});

const REGION_KEYWORDS = {
  west: ['jurong', 'clementi', 'bukit batok', 'choa chu kang', 'boon lay'],
  east: ['tampines', 'pasir ris', 'bedok', 'changi', 'paya lebar'],
  north: ['woodlands', 'yishun', 'sembawang', 'admiralty', 'khatib'],
  south: ['sentosa', 'harbourfront', 'telok blangah', 'alexandra', 'tiong bahru'],
  central: ['orchard', 'newton', 'novena', 'toa payoh', 'bishan']
} as const;

class RegionClassificationError extends Error {
  constructor(
    public readonly code: 'INVALID_ADDRESS' | 'INVALID_POSTAL' | 'REGION_NOT_FOUND',
    message: string
  ) {
    super(message);
    this.name = 'RegionClassificationError';
  }
}

export const locationClassifier = {
  validateAddress(address: string): Address {
    try {
      const postalCode = this.extractPostalCode(address);
      if (!postalCode) {
        throw new RegionClassificationError(
          'INVALID_POSTAL',
          'No valid postal code found in address'
        );
      }

      const unit = this.extractUnit(address);
      const building = this.extractBuilding(address);
      const street = address
        .replace(postalCode, '')
        .replace(unit || '', '')
        .replace(building || '', '')
        .trim();

      const validatedAddress = addressSchema.parse({
        street,
        postalCode,
        unit
      });

      return validatedAddress;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new RegionClassificationError(
          'INVALID_ADDRESS',
          'Invalid address format: ' + error.errors[0].message
        );
      }
      throw error;
    }
  },

  classifyAddress(address: string): Region {
    try {
      // Check cache first
      const cacheKey = address.toLowerCase().trim();
      const cachedRegion = cache.get(cacheKey);
      if (cachedRegion) {
        return cachedRegion;
      }

      // Validate address
      const validatedAddress = this.validateAddress(address);

      // Try to get region from postal code first
      const region = this.getRegionFromPostalCode(validatedAddress.postalCode);
      if (region) {
        cache.set(cacheKey, region);
        return region;
      }

      // If postal code doesn't give us a region, try keyword matching
      for (const [regionName, keywords] of Object.entries(REGION_KEYWORDS)) {
        if (keywords.some(keyword => 
          address.toLowerCase().includes(keyword.toLowerCase())
        )) {
          const foundRegion = regionName as keyof typeof REGION_KEYWORDS;
          cache.set(cacheKey, foundRegion);
          return foundRegion;
        }
      }

      throw new RegionClassificationError(
        'REGION_NOT_FOUND',
        'Unable to determine region from address'
      );
    } catch (error) {
      if (error instanceof RegionClassificationError) {
        toast.error(error.message);
        throw error;
      }
      toast.error('Error classifying address');
      throw new RegionClassificationError(
        'INVALID_ADDRESS',
        'Failed to classify address'
      );
    }
  },

  extractPostalCode(address: string): string {
    const postalMatch = address.match(/\b\d{6}\b/);
    return postalMatch ? postalMatch[0] : '';
  },

  extractUnit(address: string): string | undefined {
    const unitMatch = address.match(/#\d+-\d+|\b[Bb]lk\s+\d+\b/);
    return unitMatch ? unitMatch[0] : undefined;
  },

  extractBuilding(address: string): string | undefined {
    const buildingMatch = address.match(/(?:Building|Tower|Block)\s+[A-Za-z0-9]+/i);
    return buildingMatch ? buildingMatch[0] : undefined;
  },

  getRegionFromPostalCode(postalCode: string): Region | null {
    const firstTwoDigits = parseInt(postalCode.substring(0, 2));
    
    // Singapore postal code sectors
    if (firstTwoDigits >= 1 && firstTwoDigits <= 8) return 'central';
    if (firstTwoDigits >= 9 && firstTwoDigits <= 10) return 'south';
    if (firstTwoDigits >= 11 && firstTwoDigits <= 14) return 'east';
    if (firstTwoDigits >= 15 && firstTwoDigits <= 18) return 'north';
    if (firstTwoDigits >= 19 && firstTwoDigits <= 20) return 'west';
    
    return null;
  }
};

export type { Address, Region };
undefined.displayName = 'undefined';
