import * as React from 'react';

/**
 * CRITICAL SERVICE - DO NOT MODIFY WITHOUT REVIEW
 *
 * This service handles core location and distance calculations:
 * - Distance calculation between coordinates
 * - Region determination logic
 * - Distance-based weight calculation (5-8km range)
 * - Slot availability filtering
 *
 * PROTECTED FEATURES - DO NOT REMOVE:
 * - Haversine distance calculation
 * - Weight calculation system (5-8km)
 * - Region center definitions
 * - Slot filtering logic
 * - Rate limiting protection
 *
 * Last Working State: January 2024
 * - Distance calculations accurate
 * - Weight system (5-8km) implemented
 * - Region detection working
 */

export type Region = 'north' | 'south' | 'east' | 'west' | 'central';

interface Coordinates {
  latitude: number;
  longitude: number;
}

export const REGION_CENTERS: Record<Region, Coordinates> = {
  north: { latitude: 1.4291, longitude: 103.8261 }, // Woodlands
  south: { latitude: 1.2789, longitude: 103.8536 }, // HarbourFront
  east: { latitude: 1.3526, longitude: 103.9352 }, // Tampines
  west: { latitude: 1.3329, longitude: 103.7436 }, // Jurong East
  central: { latitude: 1.3139, longitude: 103.8379 } // Orchard
};

// Constants for distance and weight calculations
const EARTH_RADIUS_KM = 6371; // Earth's radius in kilometers
const MIN_DISTANCE_KM = 5;
const MAX_DISTANCE_KM = 8;
const MIN_REQUEST_INTERVAL = 1000; // 1 second in milliseconds

let lastRequestTime = 0;

export const regionService = {
  /**
   * Calculates the distance between two points using the Haversine formula
   * @param point1 First coordinate point
   * @param point2 Second coordinate point
   * @returns Distance in kilometers
   */
  calculateDistance(point1: Coordinates, point2: Coordinates): number {
    const toRad = (x: number) => (x * Math.PI) / 180;

    const dLat = toRad(point2.latitude - point1.latitude);
    const dLon = toRad(point2.longitude - point1.longitude);

    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(toRad(point1.latitude)) *
        Math.cos(toRad(point2.latitude)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS_KM * c;
  },

  /**
   * Calculates a weight based on distance for slot availability
   * @param distance Distance in kilometers
   * @returns Weight between 0 and 1
   */
  calculateWeight(distance: number): number {
    if (distance <= MIN_DISTANCE_KM) return 1;
    if (distance >= MAX_DISTANCE_KM) return 0;

    // Linear interpolation between min and max distance
    return (MAX_DISTANCE_KM - distance) / (MAX_DISTANCE_KM - MIN_DISTANCE_KM);
  },

  /**
   * Finds the nearest region center to a given coordinate
   * @param coordinates Location coordinates
   * @returns Nearest region
   */
  async findNearestRegion(coordinates: Coordinates): Promise<Region> {
    // Rate limiting
    const now = Date.now();
    const timeSinceLastRequest = now - lastRequestTime;
    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
      await new Promise(resolve => 
        setTimeout(resolve, MIN_REQUEST_INTERVAL - timeSinceLastRequest)
      );
    }
    lastRequestTime = now;

    let nearestRegion: Region = 'central';
    let minDistance = Infinity;

    for (const [region, center] of Object.entries(REGION_CENTERS)) {
      const distance = this.calculateDistance(coordinates, center);
      if (distance < minDistance) {
        minDistance = distance;
        nearestRegion = region as Region;
      }
    }

    return nearestRegion;
  },

  /**
   * Checks if a location is within serviceable range
   * @param coordinates Location coordinates
   * @param regionCenter Center coordinates of a region
   * @returns Boolean indicating if location is serviceable
   */
  isWithinServiceableRange(coordinates: Coordinates, regionCenter: Coordinates): boolean {
    const distance = this.calculateDistance(coordinates, regionCenter);
    return distance <= MAX_DISTANCE_KM;
  }
};

export type { Coordinates };