import { Loader } from '@googlemaps/js-api-loader';

export type Geocoder;
export type AutocompleteService;
export type PlacesService;
export interface Window;
export interface AddressValidationResult;
export interface PlaceDetails;
export interface PlacePrediction;





























// Type declarations for Google Maps
type Geocoder = {
  geocode(request: { address: string; componentRestrictions?: { country: string } }): Promise<{
    results: Array<{
      address_components: Array<{
        long_name: string;
        types: string[];
      }>;
      formatted_address: string;
      geometry: {
        location: {
          lat(): number;
          lng(): number;
        };
      };
    }>;
  }>;
};

type AutocompleteService = {
  getPlacePredictions(request: {
    input: string;
    componentRestrictions?: { country: string };
  }): Promise<{
    predictions: Array<{
      place_id: string;
      structured_formatting: {
        main_text: string;
        secondary_text?: string;
      };
    }>;
  }>;
};

type PlacesService = {
  getDetails(
    request: {
      placeId: string;
      fields: string[];
    },
    callback: (
      result: {
        address_components?: Array<{
          long_name: string;
          types: string[];
        }>;
        formatted_address?: string;
        geometry?: {
          location?: {
            lat(): number;
            lng(): number;
          };
        };
      } | null,
      status: string
    ) => void
  ): void;
};

declare global {
  interface Window {
    google: {
      maps: {
        Geocoder: new () => Geocoder;
        places: {
          AutocompleteService: new () => AutocompleteService;
          PlacesService: new (div: HTMLDivElement) => PlacesService;
          PlacesServiceStatus: {
            OK: 'OK';
            ZERO_RESULTS: 'ZERO_RESULTS';
            ERROR: 'ERROR';
          };
        };
      };
    };
  }
}


  components?: {
    postalCode?: string;
    streetName?: string;
    district?: string;
  };
  formattedAddress?: string;
  latitude?: number;
  longitude?: number;
}


  streetAddress?: string;
  district?: string;
  formattedAddress?: string;
  latitude?: number;
  longitude?: number;
}


  structured_formatting: {
    main_text: string;
    secondary_text?: string;
  };
}

const GOOGLE_MAPS_API_KEY = import.meta.env.VITE_GOOGLE_PLACES_API_KEY;

// Initialize the loader
const loader = new Loader({
  apiKey: GOOGLE_MAPS_API_KEY,
  version: 'weekly',
  libraries: ['places'],
});

/**
 * Initialize Google Places API
 * @returns Promise that resolves when Google Places API is loaded
 */
export const initGooglePlaces = async (): Promise<void> => {
  try {
    await loader.load();
  } catch (error) {
    console.error('Failed to load Google Places API:', error);
    throw error;
  }
};

/**
 * Google Places service
 */
const googlePlacesService = {
  /**
   * Validate a Singapore address using Google Geocoding API
   * @param address Address to validate
   * @returns Validation result with address components
   */
  validateAddress: async (address: string): Promise<AddressValidationResult> => {
    try {
      await loader.load();
      const geocoder = new window.google.maps.Geocoder();
      const response = await geocoder.geocode({
        address,
        componentRestrictions: { country: 'SG' },
      });

      if (!response.results.length) {
        return { isValid: false };
      }

      const result = response.results[0];
      const components = result.address_components.reduce(
        (acc, component) => {
          if (component.types.includes('postal_code')) {
            acc.postalCode = component.long_name;
          } else if (component.types.includes('route')) {
            acc.streetName = component.long_name;
          } else if (component.types.includes('sublocality')) {
            acc.district = component.long_name;
          }
          return acc;
        },
        {} as AddressValidationResult['components']
      );

      return {
        isValid: true,
        components,
        formattedAddress: result.formatted_address,
        latitude: result.geometry.location.lat(),
        longitude: result.geometry.location.lng(),
      };
    } catch (error) {
      console.error('Error validating address:', error);
      return { isValid: false };
    }
  },

  /**
   * Get the Google Places Autocomplete service
   * @returns Autocomplete service instance
   */
  getAutocompleteService: async (): Promise<AutocompleteService> => {
    try {
      await loader.load();
      return new window.google.maps.places.AutocompleteService();
    } catch (error) {
      console.error('Error getting autocomplete service:', error);
      throw error;
    }
  },

  /**
   * Get place predictions for an input string
   * @param input Search input
   * @param autocompleteService Autocomplete service instance
   * @returns List of place predictions
   */
  getPlacePredictions: async (
    input: string,
    autocompleteService: AutocompleteService
  ): Promise<PlacePrediction[]> => {
    try {
      const response = await autocompleteService.getPlacePredictions({
        input,
        componentRestrictions: { country: 'SG' },
      });

      return response.predictions.map((prediction) => ({
        place_id: prediction.place_id,
        structured_formatting: prediction.structured_formatting,
      }));
    } catch (error) {
      console.error('Error getting place predictions:', error);
      return [];
    }
  },

  /**
   * Get details for a place
   * @param placeId Place ID from Google Places
   * @returns Place details
   */
  getPlaceDetails: async (placeId: string): Promise<PlaceDetails | null> => {
    try {
      await loader.load();
      const placesDiv = document.createElement('div');
      const placesService = new window.google.maps.places.PlacesService(placesDiv);

      return new Promise((resolve) => {
        placesService.getDetails(
          {
            placeId,
            fields: ['address_components', 'formatted_address', 'geometry'],
          },
          (result, status) => {
            if (status === window.google.maps.places.PlacesServiceStatus.OK && result) {
              const details: PlaceDetails = {};

              if (result.address_components) {
                result.address_components.forEach((component) => {
                  if (component.types.includes('postal_code')) {
                    details.postalCode = component.long_name;
                  } else if (component.types.includes('route')) {
                    details.streetAddress = component.long_name;
                  } else if (component.types.includes('sublocality')) {
                    details.district = component.long_name;
                  }
                });
              }

              if (result.formatted_address) {
                details.formattedAddress = result.formatted_address;
              }

              if (result.geometry?.location) {
                details.latitude = result.geometry.location.lat();
                details.longitude = result.geometry.location.lng();
              }

              resolve(details);
            } else {
              resolve(null);
            }
          }
        );
      });
    } catch (error) {
      console.error('Error getting place details:', error);
      return null;
    }
  },
};

export default googlePlacesService;

undefined.displayName = 'undefined';