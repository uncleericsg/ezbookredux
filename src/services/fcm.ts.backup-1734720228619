import axios from 'axios';
import { initializeApp } from 'firebase/app';
import { getMessaging, isSupported } from 'firebase/messaging';
import { toast } from 'sonner';
import { z } from 'zod';

export interface NotificationPayload;
export interface FCMConfig;
export interface SendOptions;

interface NotificationPayload {
  title: string;
  body?: string;
  imageUrl?: string;
  data?: Record<string, string>;
}

interface FCMConfig {
  apiKey: string;
  authDomain: string;
  projectId: string;
  storageBucket: string;
  messagingSenderId: string;
  appId: string;
}

interface SendOptions {
  priority?: 'high' | 'normal';
  timeToLive?: number;
  collapseKey?: string;
  retries?: number;
  retryDelay?: number;
}

const firebaseConfig: FCMConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID
};

const app = initializeApp(firebaseConfig);
let messaging: ReturnType<typeof getMessaging> | null = null;

/**
 * Initialize Firebase Cloud Messaging
 * @returns Promise<boolean> True if FCM is supported and initialized
 */
async function initializeMessaging(): Promise<boolean> {
  try {
    if (await isSupported()) {
      messaging = getMessaging(app);
      return true;
    }
    return false;
  } catch (error) {
    console.error('FCM initialization failed: ', error);
    return false;
  }
}

// Validation schemas
const fcmTokenSchema = z.string().regex(/^[A-Za-z0-9-_]+$/);
const notificationPayloadSchema = z.object({
  title: z.string(),
  body: z.string().optional(),
  imageUrl: z.string().url().optional(),
  data: z.record(z.string()).optional()
});

const DEFAULT_OPTIONS: Required<Pick<SendOptions, 'retries' | 'retryDelay'>> = {
  retries: 3,
  retryDelay: 1000
};

class FCMService {
  private static instance: FCMService;
  private rateLimiter: {
    tokens: number;
    lastRefill: number;
    maxTokens: number;
    refillRate: number;
  };

  private constructor() {
    // Initialize rate limiter (500 notifications per minute)
    this.rateLimiter = {
      tokens: 500,
      lastRefill: Date.now(),
      maxTokens: 500,
      refillRate: 60000 // 1 minute in milliseconds
    };
  }

  public static getInstance(): FCMService {
    if (!FCMService.instance) {
      FCMService.instance = new FCMService();
    }
    return FCMService.instance;
  }

  private async validateToken(token: string): Promise<void> {
    try {
      await fcmTokenSchema.parseAsync(token);
    } catch (error) {
      console.error('Invalid FCM token: ', error);
      throw new Error('Invalid FCM token format');
    }
  }

  private async validatePayload(payload: NotificationPayload): Promise<void> {
    try {
      await notificationPayloadSchema.parseAsync(payload);
    } catch (error) {
      console.error('Invalid notification payload: ', error);
      throw new Error('Invalid notification payload');
    }
  }

  private async checkRateLimit(): Promise<boolean> {
    const now = Date.now();
    const timePassed = now - this.rateLimiter.lastRefill;
    const tokensToAdd = Math.floor(timePassed / this.rateLimiter.refillRate) * this.rateLimiter.maxTokens;

    if (tokensToAdd > 0) {
      this.rateLimiter.tokens = Math.min(
        this.rateLimiter.maxTokens,
        this.rateLimiter.tokens + tokensToAdd
      );
      this.rateLimiter.lastRefill = now;
    }

    if (this.rateLimiter.tokens <= 0) {
      toast.error('FCM rate limit exceeded');
      return false;
    }

    this.rateLimiter.tokens--;
    return true;
  }

  private async retryOperation<T>(
    operation: () => Promise<T>,
    options: Required<Pick<SendOptions, 'retries' | 'retryDelay'>>
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= options.retries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error');
        if (attempt === options.retries) break;
        await new Promise(resolve => {
          globalThis.setTimeout(resolve, options.retryDelay * attempt);
        });
      }
    }

    throw lastError;
  }

  public async sendNotification(
    token: string,
    payload: NotificationPayload,
    options: SendOptions = {}
  ): Promise<string> {
    try {
      if (!messaging) {
        const supported = await initializeMessaging();
        if (!supported) {
          throw new Error('FCM not supported in this environment');
        }
      }

      await this.validateToken(token);
      await this.validatePayload(payload);

      if (!(await this.checkRateLimit())) {
        throw new Error('Rate limit exceeded');
      }

      const { retries, retryDelay, ...fcmOptions } = { ...DEFAULT_OPTIONS, ...options };
      const message = {
        token,
        notification: {
          title: payload.title,
          body: payload.body,
          image: payload.imageUrl
        },
        data: payload.data,
        android: {
          priority: fcmOptions.priority === 'high' ? 'high' : 'normal',
          ttl: fcmOptions.timeToLive,
          collapseKey: fcmOptions.collapseKey
        },
        apns: {
          headers: {
            'apns-priority': fcmOptions.priority === 'high' ? '10' : '5',
            'apns-collapse-id': fcmOptions.collapseKey
          }
        }
      };

      const response = await this.retryOperation(
        async () => messaging.send(message),
        { retries, retryDelay }
      );

      toast.success('Notification sent successfully');
      return response;
    } catch (error) {
      console.error('FCM send error: ', error);
      toast.error('Failed to send notification');
      throw error;
    }
  }

  private successCount = 0;
  private failureCount = 0;
  private responses: Array<{
    success: boolean;
    error?: Error;
    messageId?: string;
  }> = [];

  public async sendMulticast(
    tokens: string[],
    payload: NotificationPayload,
    options: SendOptions = {}
  ): Promise<{ successCount: number; failureCount: number; responses: Array<{ success: boolean; error?: Error; messageId?: string }> }> {
    try {
      await Promise.all(tokens.map(token => this.validateToken(token)));
      await this.validatePayload(payload);

      if (tokens.length > 500) {
        throw new Error('Maximum of 500 tokens per multicast');
      }

      if (!(await this.checkRateLimit())) {
        throw new Error('Rate limit exceeded');
      }

      const message = {
        tokens,
        notification: {
          title: payload.title,
          body: payload.body,
          image: payload.imageUrl
        },
        data: payload.data,
        android: {
          priority: options.priority === 'high' ? 'high' : 'normal',
          ttl: options.timeToLive,
          collapseKey: options.collapseKey
        },
        apns: {
          headers: {
            'apns-priority': options.priority === 'high' ? '10' : '5',
            'apns-collapse-id': options.collapseKey
          }
        }
      };

      const response = await getMessaging().sendMulticast(message);
      this.successCount = response.successCount;
      this.failureCount = response.failureCount;
      this.responses = response.responses.map(_response => ({
        success: _response.success,
        error: _response.error,
        messageId: _response.messageId
      }));
      return { successCount: this.successCount, failureCount: this.failureCount, responses: this.responses };
    } catch (error) {
      console.error('FCM multicast error: ', error);
      throw error;
    }
  }

  public async scheduleNotification(
    token: string,
    payload: NotificationPayload,
    scheduledTime: Date,
    options: SendOptions = {}
  ): Promise<string> {
    if (scheduledTime.getTime() <= Date.now()) {
      throw new Error('Scheduled time must be in the future');
    }

    try {
      // Validate inputs before scheduling
      await this.validateToken(token);
      await this.validatePayload(payload);

      // Schedule notification
      const response = await axios.post('/api/notifications/schedule', {
        token,
        payload,
        scheduledTime: scheduledTime.toISOString(),
        options
      });

      toast.success('Notification scheduled successfully');
      return response.data.id;
    } catch (error) {
      console.error('Failed to schedule notification: ', error);
      toast.error('Failed to schedule notification');
      throw error;
    }
  }
}

const fcmService = FCMService.getInstance();
export { fcmService as default };
export { FCMService };

// Export types and schemas
export type { NotificationPayload, SendOptions, FCMConfig };
export { fcmTokenSchema, notificationPayloadSchema };