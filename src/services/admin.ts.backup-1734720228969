import axios from 'axios';
import * as JSZip from 'jszip';
import { toast } from 'sonner';

import type { User } from '@/types';
import type { AppSettings } from '@/types/appSettings';
import { generateChecksum } from '@/utils/cryptoUtils';

export interface BrandingSettings;
export interface AnalyticsData;
export interface BuildVersion;

export interface BrandingSettings {
  primaryColor: string;
  secondaryColor: string;
  logo: File | null;
  darkMode: boolean;
}

export interface AnalyticsData {
  bookings: Array<{
    month: string;
    count: number;
  }>;
  satisfaction: Array<{
    rating: number;
    count: number;
  }>;
  metrics: {
    activeAMCs: number;
    completedServices: number;
    averageRating: number;
  };
}

export interface BuildVersion {
  id: string;
  version: string;
  buildNumber: number;
  timestamp: string;
  files: string[];
  active: boolean;
  metadata: {
    gitCommit?: string;
    environment: string;
    buildTime: string;
    compiler: string;
    dependencies: Record<string, string>;
  };
  stats: {
    size: number;
    fileCount: number;
    compressedSize: number;
  };
}

/**
 * Get user from local storage
 * @returns User object or null if not found
 */
function getUser(): User | null {
  try {
    return JSON.parse(globalThis.localStorage.getItem('auth_user') || '{}');
  } catch {
    return null;
  }
}

/**
 * Log settings restore event
 * @param event Event details
 */
async function logSettingsRestore(event: { timestamp: string; success: boolean; error?: string }): Promise<void> {
  // Implementation would go here - for now just log to toast
  if (event.success) {
    toast.success('Settings restore event logged');
  } else {
    toast.error(`Settings restore failed: ${event.error}`);
  }
}

/**
 * Backup app settings to a ZIP file
 * @returns Promise resolving to a Blob containing the backup
 */
export async function backupSettings(): Promise<Blob> {
  const user = getUser();
  if (!user || user.role !== 'admin') {
    throw new Error('Admin authentication required');
  }

  const settings = {
    app: {} as AppSettings,
    metadata: {
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    }
  };

  const settingsJson = JSON.stringify(settings);
  const checksum = await generateChecksum(settingsJson);
  settings.metadata.checksum = checksum;

  const zip = new JSZip();
  zip.file('settings.json', JSON.stringify(settings, null, 2));
  zip.file('manifest.json', JSON.stringify({
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    checksum
  }, null, 2));

  return await zip.generateAsync({ type: 'blob' });
}

/**
 * Restore app settings from a backup file
 * @param file The backup file to restore from
 */
export async function restoreSettings(file: File): Promise<void> {
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    throw new Error('Backup file exceeds maximum size limit');
  }

  if (!file.name.endsWith('.zip')) {
    throw new Error('Invalid backup file format - must be a ZIP file');
  }

  const zip = new JSZip();
  const contents = await zip.loadAsync(file);
  const settingsFile = contents.file('settings.json');
  const manifestFile = contents.file('manifest.json');

  if (!settingsFile || !manifestFile) {
    throw new Error('Invalid backup file format');
  }

  const settings = JSON.parse(await settingsFile.async('string'));
  const manifest = JSON.parse(await manifestFile.async('string'));

  if (!manifest.version.startsWith('1.0')) {
    throw new Error('Unsupported backup version');
  }

  const settingsChecksum = await generateChecksum(JSON.stringify(settings));
  if (settingsChecksum !== manifest.checksum) {
    throw new Error('Backup file integrity check failed');
  }

  await logSettingsRestore({
    timestamp: new Date().toISOString(),
    success: true
  });

  toast.success('Settings restored successfully');
}

/**
 * Update branding settings
 * @param settings The new branding settings
 */
export async function updateBrandingSettings(settings: BrandingSettings): Promise<void> {
  if (import.meta.env.DEV) {
    globalThis.document.documentElement.style.setProperty('--primary-color', settings.primaryColor);
    globalThis.document.documentElement.style.setProperty('--secondary-color', settings.secondaryColor);
    await new Promise(resolve => globalThis.setTimeout(resolve, 500));
    return;
  }

  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const formData = new FormData();
  Object.entries(settings).forEach(([key, value]) => {
    if (value instanceof File) {
      formData.append(key, value);
    } else if (value !== undefined) {
      formData.append(key, String(value));
    }
  });

  await axios.post('/api/admin/settings/branding', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      Authorization: `Bearer ${user.token}`
    }
  });
}

/**
 * Get analytics data
 * @returns Promise resolving to analytics data
 */
export async function getAnalytics(): Promise<AnalyticsData> {
  if (import.meta.env.DEV) {
    return {
      bookings: [
        { month: 'Jan', count: 45 },
        { month: 'Feb', count: 52 },
        { month: 'Mar', count: 48 },
        { month: 'Apr', count: 58 },
        { month: 'May', count: 62 }
      ],
      satisfaction: [
        { rating: 1, count: 2 },
        { rating: 2, count: 5 },
        { rating: 3, count: 15 },
        { rating: 4, count: 48 },
        { rating: 5, count: 30 }
      ],
      metrics: {
        activeAMCs: 250,
        completedServices: 1200,
        averageRating: 4.2
      }
    };
  }

  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const response = await axios.get('/api/admin/analytics', {
    headers: { Authorization: `Bearer ${user.token}` }
  });

  return response.data;
}

/**
 * Get all users
 * @returns Promise resolving to array of users
 */
export async function getUsers(): Promise<User[]> {
  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const response = await axios.get('/api/admin/users', {
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  });
  return response.data;
}

/**
 * Deactivate a user
 * @param userId ID of the user to deactivate
 */
export async function deactivateUser(userId: string): Promise<void> {
  const user = getUser();
  if (!user) throw new Error('Authentication required');

  if (import.meta.env.DEV) {
    await new Promise(resolve => globalThis.setTimeout(resolve, 500));
    return;
  }

  await axios.post(`/api/admin/users/${userId}/deactivate`, null, {
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  });
}

/**
 * Update a user's details
 * @param userId ID of the user to update
 * @param updates Updates to apply to the user
 * @returns Promise resolving to the updated user
 */
export async function updateUser(userId: string, updates: Partial<User>): Promise<User> {
  if (import.meta.env.DEV) {
    await new Promise(resolve => globalThis.setTimeout(resolve, 500));
    return {
      id: userId,
      ...updates,
      updatedAt: new Date().toISOString()
    } as User;
  }

  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const response = await axios.put(`/api/admin/users/${userId}`, updates, {
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  });
  return response.data;
}

/**
 * Delete multiple build versions
 * @param versionIds IDs of the versions to delete
 */
export async function deleteBuildVersions(versionIds: string[]): Promise<void> {
  const user = getUser();
  if (!user) throw new Error('Authentication required');

  await axios.post('/api/admin/build/delete-bulk', { versionIds }, {
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  });
}

/**
 * Calculate the next service date
 * @param lastServiceDate Date of the last service
 * @param intervalWeeks Number of weeks between services
 * @returns The next service date
 */
export function calculateNextServiceDate(lastServiceDate: Date, intervalWeeks: number): Date {
  const nextDate = new Date(lastServiceDate);
  nextDate.setDate(nextDate.getDate() + (intervalWeeks * 7));
  return nextDate;
}

/**
 * Validate a build version object
 * @param version The version to validate
 * @returns True if the version is valid
 */
export function validateBuildVersion(version: BuildVersion): boolean {
  const semverRegex = /^\d+\.\d+\.\d+$/;
  return (
    semverRegex.test(version.version) &&
    version.buildNumber > 0 &&
    version.metadata.environment !== undefined &&
    version.stats.size > 0
  );
}

/**
 * Upload a new build
 * @param files Files to upload
 * @param environment Target environment
 * @param onProgress Progress callback
 * @returns Promise resolving to the uploaded build version
 */
export async function uploadBuild(
  files: FileList,
  environment: string,
  onProgress?: (progress: number) => void
): Promise<BuildVersion> {
  const formData = new FormData();
  const zipFile = Array.from(files).find(f => f.name.endsWith('.zip'));
  if (!zipFile) {
    throw new Error('Please upload a ZIP file containing the build files');
  }

  const maxSize = 100 * 1024 * 1024; // 100MB
  if (zipFile.size > maxSize) {
    throw new Error('Build file exceeds 100MB limit');
  }

  formData.append('build', zipFile);
  formData.append('metadata', JSON.stringify({ environment }));

  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const response = await axios.post('/api/admin/build/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      Authorization: `Bearer ${user.token}`
    },
    onUploadProgress: (progressEvent) => {
      if (progressEvent.total) {
        const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
        onProgress?.(progress);
      }
    }
  });

  const version = response.data;
  if (!validateBuildVersion(version)) {
    throw new Error('Invalid server response');
  }

  return version;
}

/**
 * Get all build versions
 * @returns Promise resolving to array of build versions
 */
export async function getBuildVersions(): Promise<BuildVersion[]> {
  if (import.meta.env.DEV) {
    return [
      {
        id: 'mock-1',
        version: '1.0.0',
        buildNumber: 1,
        timestamp: new Date().toISOString(),
        files: ['app.js', 'styles.css'],
        active: true,
        metadata: {
          environment: 'development',
          buildTime: new Date().toISOString(),
          compiler: 'webpack',
          dependencies: {}
        },
        stats: {
          size: 1024,
          fileCount: 2,
          compressedSize: 512
        }
      }
    ];
  }

  const user = getUser();
  if (!user) throw new Error('Authentication required');

  const response = await axios.get('/api/admin/build/versions', {
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  });

  const versions = response.data;
  if (!versions.every(validateBuildVersion)) {
    throw new Error('Invalid version data received');
  }

  return versions;
}