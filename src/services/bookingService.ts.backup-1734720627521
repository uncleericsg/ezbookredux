import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  limit,
  getDocs,
  updateDoc,
  doc,
  type DocumentReference,
  type QuerySnapshot
} from 'firebase/firestore';

import { db } from '@/config/firebase';

export type DocumentReference,
  type QuerySnapshot
} from 'firebase/firestore';

export type QuerySnapshot;

export interface CustomerInfo;

export interface BookingDetails;


  lastName: string;
  email: string;
  mobile: string;
  floorUnit: string;
  blockStreet: string;
  postalCode: string;
  condoName?: string;
  lobbyTower?: string;
  specialInstructions?: string;
}

  issues: string[];
  lastServiceDate: string;
  customerInfo: CustomerInfo;
  status?: 'pending' | 'confirmed' | 'completed' | 'cancelled';
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Create a new booking
 * @param bookingDetails Details of the booking
 * @returns Promise resolving to booking ID
 * @throws Error if booking creation fails
 */
export async function createBooking(bookingDetails: BookingDetails): Promise<string> {
  try {
    const bookingCollection = collection(db, 'bookings');
    const docRef: DocumentReference = await addDoc(bookingCollection, {
      ...bookingDetails,
      createdAt: new Date().toISOString(),
      status: bookingDetails.status ?? 'pending'
    });
    return docRef.id;
  } catch (error) {
    console.error('Error creating booking:', error);
    throw new Error('Failed to create booking');
  }
}

/**
 * Get the last booking for a user
 * @param userId User's email
 * @returns Promise resolving to booking details or null if not found
 * @throws Error if fetching fails
 */
export async function getLastBooking(userId: string): Promise<BookingDetails | null> {
  try {
    const bookingCollection = collection(db, 'bookings');
    const q = query(
      bookingCollection,
      where('customerInfo.email', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(1)
    );
    
    const querySnapshot: QuerySnapshot = await getDocs(q);
    if (querySnapshot.empty) {
      return null;
    }
    
    return querySnapshot.docs[0].data() as BookingDetails;
  } catch (error) {
    console.error('Error fetching last booking:', error);
    throw new Error('Failed to fetch last booking');
  }
}

/**
 * Update an existing booking
 * @param bookingId ID of the booking to update
 * @param updateData Data to update
 * @throws Error if update fails
 */
export async function updateBooking(
  bookingId: string,
  updateData: Partial<BookingDetails>
): Promise<void> {
  try {
    const bookingRef = doc(db, 'bookings', bookingId);
    await updateDoc(bookingRef, {
      ...updateData,
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error updating booking:', error);
    throw new Error('Failed to update booking');
  }
}

undefined.displayName = 'undefined';