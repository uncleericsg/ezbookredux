 import { useState, useCallback } from 'react';
import { toast } from 'sonner';

import { FCMService, type NotificationPayload } from '../services/fcm';

export type NotificationPayload;
export interface FCMResponse;
export interface UseFCMCallbacks;
export type UseFCMOptions;
export interface UseFCMReturn;

export type NotificationPayload;
export interface FCMResponse;
export interface UseFCMCallbacks;
export type UseFCMOptions;
export interface UseFCMReturn;

export interface FCMResponse {
  success: boolean;
  messageId?: string;
  error?: string;
}

export interface UseFCMCallbacks {
  onSuccess(response: FCMResponse): void;
  onError(error: Error): void;
}

export type UseFCMOptions = Partial<UseFCMCallbacks>;

export interface UseFCMReturn {
  loading: boolean;
  error: Error | null;
  sendNotification: (
    token: string,
    payload: NotificationPayload,
    priority?: 'high' | 'normal'
  ) => Promise<FCMResponse>;
  subscribeToTopic: (topic: string) => Promise<FCMResponse>;
  unsubscribeFromTopic: (topic: string) => Promise<FCMResponse>;
}

export function useFCM(options: UseFCMOptions = {}): UseFCMReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const handleError = useCallback((err: unknown, defaultMessage: string) => {
    const error = err instanceof Error ? err : new Error(defaultMessage);
    setError(error);
    toast.error(error.message);
    options.onError?.(error);
    return {
      success: false,
      error: error.message
    };
  }, [options]);

  const sendNotification = useCallback(
    async (
      token: string,
      payload: NotificationPayload,
      priority: 'high' | 'normal' = 'normal'
    ): Promise<FCMResponse> => {
      if (!token) {
        return handleError(new Error('FCM token is required'), 'FCM token is required');
      }

      try {
        setLoading(true);
        setError(null);

        const response = await FCMService.sendNotification(token, payload, { priority });
        
        const fcmResponse: FCMResponse = {
          success: true,
          messageId: response.messageId
        };

        toast.success('Notification sent successfully');
        options.onSuccess?.(fcmResponse);
        
        return fcmResponse;
      } catch (err) {
        return handleError(err, 'Failed to send notification');
      } finally {
        setLoading(false);
      }
    },
    [options, handleError]
  );

  const subscribeToTopic = useCallback(
    async (topic: string): Promise<FCMResponse> => {
      if (!topic) {
        return handleError(new Error('Topic name is required'), 'Topic name is required');
      }

      try {
        setLoading(true);
        setError(null);

        const response = await FCMService.subscribeToTopic(topic);
        
        const fcmResponse: FCMResponse = {
          success: true,
          messageId: response.messageId
        };

        toast.success(`Subscribed to ${topic} successfully`);
        options.onSuccess?.(fcmResponse);
        
        return fcmResponse;
      } catch (err) {
        return handleError(err, `Failed to subscribe to ${topic}`);
      } finally {
        setLoading(false);
      }
    },
    [options, handleError]
  );

  const unsubscribeFromTopic = useCallback(
    async (topic: string): Promise<FCMResponse> => {
      if (!topic) {
        return handleError(new Error('Topic name is required'), 'Topic name is required');
      }

      try {
        setLoading(true);
        setError(null);

        const response = await FCMService.unsubscribeFromTopic(topic);
        
        const fcmResponse: FCMResponse = {
          success: true,
          messageId: response.messageId
        };

        toast.success(`Unsubscribed from ${topic} successfully`);
        options.onSuccess?.(fcmResponse);
        
        return fcmResponse;
      } catch (err) {
        return handleError(err, `Failed to unsubscribe from ${topic}`);
      } finally {
        setLoading(false);
      }
    },
    [options, handleError]
  );

  return {
    loading,
    error,
    sendNotification,
    subscribeToTopic,
    unsubscribeFromTopic
  };
}