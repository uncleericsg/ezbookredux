import { useState } from 'react';

import { db } from '../lib/database';
import { TeamAssignmentService } from '../services/teams/teamAssignment';

interface BookingData {
  date: string;
  serviceId: string;
  customerId: string;
  location?: string;
  notes?: string;
}

interface BookingResponse {
  id: string;
  date: string;
  status: string;
  teamId?: string;
  customerId: string;
  serviceId: string;
}

interface Team {
  id: string;
  name: string;
  availability: {
    date: string;
    slots: string[];
  }[];
}

interface UseBookingReturn {
  createBooking: (bookingData: BookingData) => Promise<BookingResponse>;
  getBookingTeam: (bookingId: string) => Promise<Team | null>;
  loading: boolean;
  error: string | null;
}

export function useBooking(): UseBookingReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const teamAssignmentService = new TeamAssignmentService();

  const notifyTeamAssignment = async (booking: BookingResponse, team: Team): Promise<void> => {
    try {
      // Implement internal notification logic here
      await db.notifications.create({
        data: {
          type: 'TEAM_ASSIGNMENT',
          bookingId: booking.id,
          teamId: team.id,
          message: `New booking assigned for ${booking.date}`
        }
      });
    } catch (err) {
      console.error('Failed to notify team:', err);
    }
  };

  const createBooking = async (bookingData: BookingData): Promise<BookingResponse> => {
    setLoading(true);
    setError(null);

    try {
      // Create the booking first
      const booking = await db.bookings.create({
        data: {
          date: bookingData.date,
          serviceId: bookingData.serviceId,
          customerId: bookingData.customerId,
          status: 'PENDING',
          location: bookingData.location,
          notes: bookingData.notes
        }
      });

      // Internally assign team without exposing to public
      const team = await teamAssignmentService.getNextAvailableTeam(bookingData.date);
      
      if (team) {
        await db.bookings.update({
          where: { id: booking.id },
          data: { teamId: team.id }
        });

        await notifyTeamAssignment(booking, team);
      }

      return {
        id: booking.id,
        date: booking.date,
        status: booking.status,
        teamId: team?.id,
        customerId: booking.customerId,
        serviceId: booking.serviceId
      };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create booking';
      setError(message);
      throw new Error(message);
    } finally {
      setLoading(false);
    }
  };

  const getBookingTeam = async (bookingId: string): Promise<Team | null> => {
    try {
      const booking = await db.bookings.findUnique({
        where: { id: bookingId },
        include: { team: true }
      });

      return booking?.team || null;
    } catch (err) {
      console.error('Failed to get booking team:', err);
      return null;
    }
  };

  return {
    createBooking,
    getBookingTeam,
    loading,
    error
  };
}