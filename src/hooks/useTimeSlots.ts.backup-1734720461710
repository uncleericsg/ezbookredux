/// <reference lib="dom" />
import { format } from 'date-fns';
import { useState, useRef, useCallback, useEffect } from 'react';
import { toast } from 'sonner';

import { fetchAvailableSlots } from '../services/apiService';
import { TimeSlot } from '../types';
import { withRetry } from '../utils/retry';
import { validateTimeSlot } from '../utils/validation';

export interface CacheEntry;
export interface UseTimeSlotsProps;
export interface TimeSlotsState;

export interface CacheEntry;
export interface UseTimeSlotsProps;
export interface TimeSlotsState;

export interface CacheEntry;
export interface UseTimeSlotsProps;
export interface TimeSlotsState;

export interface CacheEntry;
export interface UseTimeSlotsProps;
export interface TimeSlotsState;

const CACHE_KEY_FORMAT = 'yyyy-MM-dd';
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

interface CacheEntry {
  slots: TimeSlot[];
  timestamp: number;
  categoryId: string;
}

interface UseTimeSlotsProps {
  selectedDate: Date | null;
  categoryId: string | null;
  isAMC?: boolean;
}

interface TimeSlotsState {
  slots: TimeSlot[];
  loading: boolean;
  error: Error | null;
}

export const useTimeSlots = ({ selectedDate, categoryId, isAMC = false }: UseTimeSlotsProps) => {
  const [state, setState] = useState<TimeSlotsState>({
    slots: [],
    loading: false,
    error: null
  });

  const cache = useRef<CacheEntry[]>([]);

  const getCachedSlots = useCallback((date: Date, category: string): TimeSlot[] | null => {
    const cacheKey = format(date, CACHE_KEY_FORMAT);
    const cached = cache.current.find(c => c.categoryId === category && c.timestamp > Date.now() - CACHE_DURATION && c.cacheKey === cacheKey);
    
    if (cached) {
      return cached.slots;
    }
    return null;
  }, []);

  const setCachedSlots = useCallback((date: Date, slots: TimeSlot[], category: string) => {
    const cacheKey = format(date, CACHE_KEY_FORMAT);
    cache.current.push({
      cacheKey,
      slots,
      timestamp: Date.now(),
      categoryId: category
    });
  }, []);

  const validateSlot = useCallback((slot: TimeSlot): boolean => {
    const validation = validateTimeSlot(slot, isAMC, []);
    return validation.isValid;
  }, [isAMC]);

  const loadSlots = useCallback(async () => {
    if (!selectedDate || !categoryId) {
      setState(prev => ({ ...prev, slots: [], error: null }));
      return;
    }

    const cachedSlots = getCachedSlots(selectedDate, categoryId);

    if (cachedSlots) {
      setState(prev => ({
        ...prev,
        slots: cachedSlots.filter(slot => validateSlot(slot)),
        loading: false
      }));
      return;
    }

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const response = await withRetry(
        () => fetchAvailableSlots(
          selectedDate,
          categoryId
        ),
        {
          maxAttempts: 3,
          onRetry: (attempt, max) => {
            toast.loading(`Retrying... (${attempt}/${max})`);
          }
        }
      );

      if (!response) {
        throw new Error('Failed to fetch time slots');
      }

      const validSlots = response.filter((slot: TimeSlot) => validateSlot(slot));

      setCachedSlots(selectedDate, validSlots, categoryId);
      setState(prev => ({
        ...prev,
        slots: validSlots,
        loading: false
      }));
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch time slots');
      setState(prev => ({
        ...prev,
        error,
        loading: false
      }));
      toast.error(error.message);
    }
  }, [selectedDate, categoryId, getCachedSlots, setCachedSlots, validateSlot]);

  useEffect(() => {
    let mounted = true;
    void loadSlots();

    return () => {
      mounted = false;
    };
  }, [loadSlots]);

  return {
    ...state,
    loadSlots
  };
};
undefined.displayName = 'undefined';
