import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useCallback, useMemo, useEffect } from 'react';
import { toast } from 'sonner';

import { fetchNotifications, markNotificationAsRead } from '../services/notifications';
import { useAppSelector } from '../store';

export interface Notification;

export interface UseNotificationsReturn;


  type: string;
  title: string;
  message: string;
  createdAt: string;
  read: boolean;
  priority: 'high' | 'medium' | 'low';
  actionUrl?: string;
}

export function useNotifications(): UseNotificationsReturn {
  const queryClient = useQueryClient();
  const { currentUser } = useAppSelector((state) => state.user);

  const { data: notifications = [], isLoading, error } = useQuery({
    queryKey: ['notifications', currentUser?.id],
    queryFn: () => fetchNotifications(),
    enabled: !!currentUser,
    staleTime: 1000 * 60 * 5, // 5 minutes
    cacheTime: 1000 * 60 * 30, // 30 minutes
  });

  useEffect(() => {
    if (error) {
      toast.error(`Failed to fetch notifications: ${error.message}`);
    }
  }, [error]);

  const markAsReadMutation = useMutation({
    mutationFn: markNotificationAsRead,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
      toast.success('Notification marked as read');
    },
    onError: (error: Error) => {
      toast.error(`Failed to mark notification as read: ${error.message}`);
    },
  });

  const handleMarkAsRead = useCallback(
    (notificationId: string) => {
      if (!notificationId) {
        toast.error('Invalid notification ID');
        return;
      }
      markAsReadMutation.mutate(notificationId);
    },
    [markAsReadMutation]
  );

  const handleMarkAllRead = useCallback(() => {
    const unreadNotifications = notifications.filter((notification) => !notification.read);
    if (unreadNotifications.length === 0) {
      toast.info('No unread notifications');
      return;
    }
    unreadNotifications.forEach((notification) => {
      markAsReadMutation.mutate(notification.id);
    });
  }, [notifications, markAsReadMutation]);

  const unreadCount = useMemo(
    () => notifications.filter((notification) => !notification.read).length,
    [notifications]
  );

  useEffect(() => {
    return () => {
      queryClient.removeQueries({ queryKey: ['notifications'] });
    };
  }, [queryClient]);

  return {
    notifications,
    isLoading,
    unreadCount,
    handleMarkAsRead,
    handleMarkAllRead,
  };
}

export type { Notification };
export default useNotifications;

undefined.displayName = 'undefined';