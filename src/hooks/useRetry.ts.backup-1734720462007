import { useState, useCallback } from 'react';

export interface RetryOptions;
export interface RetryState;

export interface RetryOptions;
export interface RetryState;

export interface RetryOptions;
export interface RetryState;

export interface RetryOptions;
export interface RetryState;

interface RetryOptions {
  maxAttempts?: number;
  initialDelay?: number;
  maxDelay?: number;
  backoffFactor?: number;
}

interface RetryState {
  attempts: number;
  error: Error | null;
  loading: boolean;
}

export const useRetry = (options: RetryOptions = {}) => {
  const {
    maxAttempts = 3,
    initialDelay = 1000,
    maxDelay = 10000,
    backoffFactor = 2
  } = options;

  const [state, setState] = useState<RetryState>({
    attempts: 0,
    error: null,
    loading: false
  });

  const reset = useCallback(() => {
    setState({
      attempts: 0,
      error: null,
      loading: false
    });
  }, []);

  const execute = useCallback(async <T>(
    operation: () => Promise<T>
  ): Promise<T> => {
    setState(prev => ({
      ...prev,
      loading: true,
      error: null
    }));

    try {
      const result = await operation();
      setState(prev => ({
        ...prev,
        loading: false,
        attempts: 0
      }));
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Operation failed');
      
      if (state.attempts >= maxAttempts - 1) {
        setState(prev => ({
          ...prev,
          loading: false,
          error
        }));
        throw error;
      }

      // Calculate delay with exponential backoff
      const delay = Math.min(
        initialDelay * Math.pow(backoffFactor, state.attempts),
        maxDelay
      );

      await new Promise(resolve => setTimeout(resolve, delay));

      setState(prev => ({
        ...prev,
        attempts: prev.attempts + 1
      }));

      return execute(operation);
    }
  }, [state.attempts, maxAttempts, initialDelay, maxDelay, backoffFactor]);

  return {
    execute,
    reset,
    attempts: state.attempts,
    error: state.error,
    loading: state.loading
  };
};
undefined.displayName = 'undefined';
